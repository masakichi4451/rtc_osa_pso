% \documentclass[10pt, letterpaper]{IEEEtran}
\documentclass[conference]{IEEEtran}
\usepackage[dvipdfmx]{color}
\usepackage[dvipdfmx]{graphicx}

% 日本語対応のCJKパッケージ
\usepackage{CJKutf8}

% ページ番号を削除 2025/7/2追加
\pagestyle{empty}

%\setlength{\textwidth}{17cm}
%\setlength{\textheight}{25cm}
%\setlength{\topmargin}{-1cm}
%\setlength{\oddsidemargin}{-0.5cm}
%\setlength{\evensidemargin}{1cm}
%\setlength{\voffset}{-1cm}
%\usepackage{flushend}
\setlength\intextsep{0pt}
\setlength\textfloatsep{0pt}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{cite}
\usepackage{url}
%\usepackage{showframe}
\usepackage{subfigure}
%\usepackage{subcaption}
\usepackage{comment}
\usepackage{diagbox}  % 表内でセルを斜めに分割するため．2024/12/18追加

\usepackage{amssymb}
\usepackage{xcolor} %色を変えるために追加
% \usepackage{ulem} % 打ち消し線のため  % 2025/3/25 雑誌名にアンダーラインがつくし，もう不要なのでコメントアウト
% \usepackage{amsthm} % Theoremと表示するため
\usepackage{amsmath,algorithm,float,tabularx,amsfonts} % Algorithm書くため
\usepackage{algpseudocode} % Algorithm書くため
\usepackage{graphics} % \scaleboxを使うため
\newcommand{\multiline}[1]{% 複数行に渡るときに左端を揃えるため
    \begin{tabularx}{\dimexpr\linewidth-\ALG@thistlm}[t]{@{}X@{}}
        #1
    \end{tabularx}
}
\newcommand{\Step}[1]{\algrenewcommand{\alglinenumber}[1]{\textbf{Step ##1.} } #1} % AlgorithmでStep 1. と表示するため
\newcommand{\Stepmini}[1]{\algrenewcommand{\alglinenumber}[1]{\textbf{Step 1-##1.} } #1} % AlgorithmでStep 1-1. と表示するため
\newcommand{\NoNumber}{\algrenewcommand{\alglinenumber}[1]{\setcounter{ALG@line}{\numexpr##1-1} \ \ \ \ \ \ \ \ \ \ }} % Algorithmでインデントつきで改行するため
\newcommand{\AdjustNumber}{\algrenewcommand{\alglinenumber}[1]{\setcounter{ALG@line}{\numexpr##1-2}}} % AlgorithmでStep番号を調整するため
\newcommand{\StartLeft}{\algrenewcommand{\alglinenumber}[1]{\setcounter{ALG@line}{\numexpr##1-1}}} % Algorithmで数式後の文章の始まりを左に揃えるため
% AlgorithmでRequireとEnsureをInputとOutputにする
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\newtheorem{thm}{Theorem} % Theoremと表示するため
\newtheorem{lemma}{Lemma} % Lemmaと表示するため

% \newtheorem{lemma}{Lemma}
\newtheorem*{proof*}{Proof}
% \newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newcommand{\argmin}{\mathop{\rm argmin}\limits}
\renewcommand\thefootnote{\dag}
%\lstset{
%    basicstyle={\ttfamily\small}, %書体の指定
%    frame=tRBl, %フレームの指定
%    framesep=10pt, %フレームと中身（コード）の間隔
%    breaklines=true, %行が長くなった場合の改行
%    linewidth=15cm, %フレームの横幅
%    lineskip=-0.5ex, %行間の調整
%    tabsize=2 %Tabを何文字幅にするかの指定
%}

\newcommand\blue[1]{\textcolor{blue}{#1}}
\newcommand\red[1]{\textcolor{red}{#1}}
\newcommand\cyan[1]{\textcolor{cyan}{#1}}
\newcommand\magenta[1]{\textcolor{magenta}{#1}}
\newcommand\green[1]{\textcolor{green}{#1}}
\newcommand\black[1]{\textcolor{black}{#1}}

\allowdisplaybreaks % 数式がページをまたぐことを許可

\bibliographystyle{IEEEtran_noemph} % bibtexのために追加．2025/7/2にbookのtitleのemphasizeを削除してイタリックにならない正常の動作にした．

\begin{document}

\begin{CJK}{UTF8}{ipxm}

\title{\Large
Optimistic Synchronization-Based Server Allocation with Preventive Start-Time Optimization for Delay-Sensitive Applications Under Server Failure
\thanks{This work was supported in part by the Japan Society for the Promotion of Science (JSPS) KAKENHI, under Grant Numbers 25K22800 and 25KF0055.}
}
\author{Masaki Oda$^\dag$, Akio Kawabata$^\ddag$, and Eiji Oki$^\dag$\\
$^\dag$Kyoto University, Kyoto, Japan\ \ $^\ddag$Toyohashi University of Technology, Aichi, Japan} 
\maketitle
\thispagestyle{empty}

% \vspace{-2cm}
\begin{abstract}
Real-time applications require low latency and strict event ordering.  
Distributed server processing is effective for this purpose, and there are two synchronization algorithms: a conservative synchronization algorithm (CSA) and an optimistic synchronization algorithm (OSA).
OSA allows servers to process events without prior order enforcement, rolling back their status to the time of the event occurrence if an out-of-order event is detected, which improves delay performance compared to CSA.
While prior studies have considered OSA, they have not incorporated the impact of server failures. 
This paper proposes an OSA-based server allocation model for delay-sensitive applications with preventive start-time optimization (PSO) under single-server failures.
The proposed model minimizes the largest total delay across all failure scenarios while satisfying the maximum status holding time constraints with PSO under single-server failures.
PSO proactively assigns users to servers to minimize the maximum delay across all failure scenarios, while ensuring that users connected to operational servers are not unnecessarily reassigned.  
We formulate the proposed model as an integer linear programming (ILP) problem.  
We prove that the decision version of the server allocation problem is NP-complete. 
Numerical results show that the proposed OSA-based model reduces the delay compared to the conventional CSA-based model by effectively utilizing server memory resources.
We observe that the proposed model achieves a lower largest total delay than start-time optimization and provides greater stability by preventing unnecessary user reassignments compared to run-time optimization.
\end{abstract}
% \vspace{-0.3cm}
\begin{IEEEkeywords}
Server allocation, optimistic synchronization algorithm, preventive start-time optimization, server failure.
\end{IEEEkeywords}

% \vspace{-0.5cm}
\section{Introduction}
\label{sec:introduction}

The advancement of fifth-generation (5G) mobile networks~\cite{DOCOMO_5G} has heightened the demand for real-time applications, such as ticket reservation systems and online gaming, which require both low latency and strict event ordering.
To ensure event order, traditional approaches rely on centralized processing (CP), where a central server coordinates the sequence of events.
However, this approach requires waiting for the slowest user response, since the central server must account for the maximum round-trip delay among all users. 
This leads to an increase in overall delay.

Some studies~\cite{OSA_Kawabata_5,OSA_Kawabata_6} have examined the advantages and limitations of parallel and distributed systems in processing events according to their actual occurrence order. 
Ensuring correct event sequencing while maintaining parallelism remains a key challenge in such systems~\cite{OSA_Kawabata_7,OSA_Kawabata_8}. 
To address this, various synchronization algorithms have been introduced, which are broadly classified into conservative synchronization algorithms (CSA) and optimistic synchronization algorithms (OSA)~\cite{OSA_Kawabata_9}. 
CSA enforces event order by associating time information with each event, thereby preserving the correct sequence. 
In contrast, OSA allows events to be processed without prior order enforcement; if an out-of-order event is detected, the system performs a rollback to guarantee the event order and corrects its results.
These synchronization techniques are particularly relevant for delay-sensitive applications, including network-based shooter games~\cite{OSA_Kawabata_10} and transaction management systems~\cite{OSA_Kawabata_11}.
While the rollback mechanism enables flexible event processing, it requires servers to retain extensive historical state information, potentially leading to higher memory usage than CSA-based methods.

The work~\cite{2Kawabata2017} introduced a distributed server processing (DSP) model with CSA, taking advantage of edge computing~\cite{edge_26,edge_27,edge_28,edge_29}. 
In this model, each user is assigned to a distributed server, and servers exchange user-generated events with one another, enabling all servers to store and manage these events, which is an additional step compared to centralized processing (CP). 
After reconstructing the event sequence according to their actual occurrence, each server processes the events.
The results are then sent back to the respective users. 
Let $D_\mathrm{U}^{\max}$ denote the maximum delay between users and servers, and $D_\mathrm{S}^{\max}$ the maximum delay between servers. 
The three communication steps—user-to-server communication, inter-server event sharing, and server-to-user response—require at most $D_\mathrm{U}^{\max}$, $D_\mathrm{S}^{\max}$, and $D_\mathrm{U}^{\max}$ time, respectively. 
Therefore, the total maximum delay for DSP with CSA is $2D_\mathrm{U}^{\max} + D_\mathrm{S}^{\max}$. 
The work in~\cite{2Kawabata2017} formulated a server assignment strategy to minimize this delay. 
For comparison, the total delay in CP is $2D_\mathrm{U}^{\max}$. 
Since DSP with CSA allows users to connect to closer servers, $D_\mathrm{U}^{\max}$ is typically reduced compared to CP, leading to a lower overall delay.

Study~\cite{OSA_Kawabata_2021,OSA_Kawabata_13_Kawabata2020} introduced a DSP model with OSA.
When a server receives an event from its assigned user, it rolls back its status to the time when the event occurs, processes the event, and sends the result back to the user immediately.
Due to the rollback mechanism, each server must retain the application's previous state until the latest possible arrival of any delayed event.
The total maximum delay for DSP with OSA is $2D_\mathrm{U}^{\max}$;
it is the round-trip delay between a user and its assigned server, where the maximum is taken over all user-server pairs. 
In other words, this represents the largest round-trip communication time between any user and the server to which they are allocated.

Server failures can arise from a range of causes, such as hardware breakdowns, software faults, or overload conditions~\cite{5_9_8_Shi2016}. 
Given the distributed nature and operational complexity of edge servers, their susceptibility to failure is generally higher than that of centralized cloud servers.
In the event of a server failure, users originally assigned to the failed server must be reallocated to alternative servers, which may impact the maximum total delay experienced in the system.
Previous work~\cite{5_9_Masuda2020} has addressed a DSP model with CSA under the assumption of single-server failures.
However, the problem of OSA-based server allocation in the presence of server failures remains insufficiently investigated.
Since single-server failures are statistically more prevalent than concurrent multiple-server failures, this study concentrates on the single-server failure scenario.

A common approach for handling server allocation under single-server failures is to first decide the optimal assignment assuming no failures, and then update the allocation as failures occur. 
In this context, start-time optimization (SO) reallocates only users connected to a failed server to minimize the total delay in each failure scenario. 
In contrast, run-time optimization (RO) allows all users to be reassigned to any available server after a failure, seeking to minimize the total delay for each scenario. 
While SO ensures the best allocation when no failures are present, it may not provide the lowest delay in the presence of failures. 
RO, on the other hand, always achieves the minimum delay for each failure scenario, but it may unnecessarily reassign users whose servers remain operational, potentially causing instability due to avoidable service interruptions.

Preventive start-time optimization (PSO) offers an alternative approach for server allocation under single-server failure scenarios. 
PSO was originally introduced in the context of network optimization~\cite{5_9_13_Kamrul2010,OkiDRCN2014} to proactively mitigate network congestion and reduce service disruptions in the presence of failures. 
In PSO, user-to-server assignments are determined in advance to minimize the largest total delay across all possible failure scenarios. 
To maintain service stability, PSO, like SO, restricts the reassignment of users whose servers remain operational, ensuring that only users affected by a server failure are reallocated. 
% サービスの中断をなくし，全ての故障シナリオを考えた時の全体の遅延時間を最小化するためにはPSOが有効である．
PSO effectively minimizes the largest total delay across all failure scenarios while avoiding unnecessary service interruptions.

A question arises: 
% モデルを開発することができるのか
Can we develop a model for the OSA-based server allocation problem with PSO against single-server failures (OSA-PSO)?

This paper proposes an OSA-based server allocation model with PSO against single-server failures.
The proposed model preventively assigns users to servers to minimize the largest total delay among all failure scenarios while satisfying the maximum status holding time constraints.
To suppress instability, the proposed model does not allow users connected to non-failed servers to be reallocated to other non-failed servers when a server fails.
We formulate the proposed model as an integer linear programming (ILP) problem.
We prove that the decision version of OSA-PSO is NP-complete.
% CSAに比べてdelayが削減される
Numerical results show that the delay of the proposed OSA-based server allocation model can be reduced compared to that of the conventional CSA-based server allocation model.
The results also show that the proposed OSA-based server allocation model with PSO against a single failure outperforms SO in terms of the largest total delay and RO in terms of avoiding instability.

% \vspace{-0.3cm}
\section{Related work and limitations of existing models}
\label{sec:related_work}

The study in~\cite{OSA_Kawabata_2021} introduced a server allocation model based on OSA. 
In this model, when a user has the option to connect to multiple servers, the resulting maximum end-to-end delay depends on which server is chosen, as the user-to-server delay varies accordingly. 
The end-to-end delay is defined as the round-trip time between a user and their assigned server. 
To minimize this delay, it is necessary to select server assignments while also considering constraints on the maximum status holding time, which are determined by application requirements and the memory capacity of each server. 
Specifically, the time a server must wait for the latest possible event from its most distant user should not exceed the maximum status holding time. 
Let $H_{\rm APL}$ represent the maximum status holding time of an application, and $H_s$ denote the maximum status holding time of server $s$. 
Both $H_{\rm APL}$ and $H_s$ are predetermined based on application design and the available memory resources at each server.

Fig.~\ref{fig:OSA_allocation} illustrates two different server allocations with OSA in the same network. 
In allocation~1 (Fig.~\ref{fig:OSA_allocation}(a)), the resulting delay is $8$ ($=4 \times 2$), while in allocation~2 (Fig.~\ref{fig:OSA_allocation}(b)), the delay increases to $14$ ($=7 \times 2$). 
The corresponding maximum status holding times are $14$ ($=4+10$) for allocation~1 and $12$ ($=7+5$) for allocation~2. 
Although allocation~1 allows user~1 to connect to the nearest server, it results in a larger maximum status holding time compared to allocation~2. 
When $\min(H_{\rm APL}, H_s) \geq 14$, allocation~1 is preferable to allocation~2; the index of $s$ used in $H_s$ is applied for all servers in the network.
If $12 \leq \min(H_{\rm APL}, H_s) < 14$, only allocation~2 satisfies the status holding time constraint, making allocation~1 infeasible. 
For $\min(H_{\rm APL}, H_s) < 12$, neither allocation is feasible. 
These observations highlight the importance of selecting an appropriate allocation that minimizes end-to-end delay while ensuring compliance with the maximum status holding time constraint in OSA.
However, the model in~\cite{OSA_Kawabata_2021} does not consider server failures.
Since this paper focuses on the single-server failures in OSA with PSO, the model in~\cite{OSA_Kawabata_2021} cannot be applied.
\begin{figure}[tb]
  \begin{center}
      %\begin{tabular}{c}
      \includegraphics[width=0.99\columnwidth]{./fig/OSA_allocation.pdf}
  \end{center}
    % \vspace{-0.4cm}
  \caption{Example of server allocations with OSA.}
  \label{fig:OSA_allocation}
\end{figure}

\begin{figure}[tb]
  \begin{center}
      %\begin{tabular}{c}
      \includegraphics[width=0.99\columnwidth]{./fig/CSA_SOROPSO.pdf}
  \end{center}
    % \vspace{-0.4cm}
  \caption{Example of CSA-based server allocation with SO, RO, and PSO.}
  \label{fig:CSA_SOROPSO}
\end{figure}
The approach in~\cite{5_9_Masuda2020} considered single-server failures in the context of CSA with PSO.
Figure~\ref{fig:CSA_SOROPSO} provides an overview of CSA-based server allocation with SO, RO, and PSO.
Let $f$ denote the failed server.
When there is no failure ($f = 0$), SO achieves the minimum total delay among feasible allocations.
However, SO restricts reassignment to only those users whose server has failed, which can result in a larger total delay compared to PSO when $f = 1$ or $2$.
For instance, under SO, if user~3 is initially assigned to server~2 for $f = 0$, then upon failure of server~1 ($f = 1$), user~3 must be reassigned to server~2, even if this does not yield the lowest possible delay.
In contrast, RO always yields the minimum total delay for any failure scenario, but it may lead to instability, as users may be reassigned to different servers even when their original server remains operational.
For example, under RO, user~3 may be assigned to server~2 when $f = 0$, but reassigned to server~3 when $f = 1$, even though server~2 has not failed.
PSO addresses this by optimizing the allocation across all failure scenarios, thereby reducing the total delay while avoiding instability.
Nevertheless, the model in~\cite{5_9_Masuda2020} does not incorporate constraints on the maximum status holding time, and thus cannot be directly applied to scenarios where such constraints are required.

\section{Proposed model: OSA-PSO}
\label{sec:proposed_mode_osa_pso}

\subsection{Problem definitions}

We present the formal definition of OSA-PSO. Let the network be represented by an undirected graph $G = (V, E)$.
Let $V$ denote the set of all nodes and $E$ the set of all edges in the network.
Let $V_{\rm{U}} \subseteq V$ be the set of users, and let $V_{\rm{S}} \subseteq V$ be the set of potential server locations, where $|V_{\rm{S}}| \geq 2$.
We can express $V_{\rm{S}}$ as $V_{\rm{S}} = \{1, \ldots, |V_{\rm{S}}|\}$.
Let $u \in V_{\rm{U}}$ represent a user and $s \in V_{\rm{S}}$ represent a server.
Note that $V_{\rm{U}} \cup V_{\rm{S}} = V$ and $V_{\rm{U}} \cap V_{\rm{S}} = \emptyset$.
Let $E_{\rm{U}} \subseteq E$ be the set of edges between users and servers, and $E_{\rm{S}} \subseteq E$ be the set of edges between servers.
An edge connecting a user $u \in V_{\rm{U}}$ to a server $s \in V_{\rm{S}}$ is represented as $(u,s) \in E_{\rm{U}}$.
An edge connecting two distinct servers $s, t \in V_{\rm{S}}$ is represented as $(s, t) \in E_{\rm{S}}$.
Note that $E_{\rm U} \cup E_{\rm S} =E$ and $E_{\rm{U}} \cap E_{\rm{S}} = \emptyset$.
Let $M_s$ be the maximum number of users that can be assigned to server $s \in V_{\rm{S}}$.
This paper assumes that no more than one server can fail simultaneously.
Let $F = \{0, 1, \ldots, |V_{\rm{S}}|\}$ be the set of possible failure scenarios, where $f = 0$ corresponds to the scenario with no server failure, and each $f \in F \setminus \{0\}$ corresponds to the failure of server~$f$.

Let $d(u,s)$ represent the delay from user $u \in V_{\rm{U}}$ to server $s \in V_{\rm{S}}$, and let $d(s,t)$ denote the delay between servers $s, t \in V_{\rm{S}}$ with $s \neq t$.
We suppose $d(u,s) \geq 0$ and $d(u,s) = d(s,u)$ for all $u \in V_{\rm{U}}$ and $s \in V_{\rm{S}}$.
In addition, we require that $d(s,t) \geq 0$ for all $s, t \in V_{\rm{S}}$, that the delays are symmetric, i.e., $d(s,t) = d(t,s)$, and that the delay from a server to itself is zero, i.e., $d(s,s) = 0$.
% We also assume that the delays between servers satisfy the triangle inequality, i.e., $d(s_1,s_2) + d(s_2,s_3) \geq d(s_1,s_3)$ for every triple of elements $s_1, s_2, s_3 \in V_{\rm{S}}$. % 近似アルゴリズムは今回ないので不要
% この後，Oda_CMNDと同じように，査読後に追加した部分とユーザには三角不等式仮定しなくていいことを述べるべき？
Let $y_{sf}$ represent a binary variable that equals one if server $s \in V_{\rm{S}}$ is chosen in failure scenario $f \in F$, and zero otherwise.
Let $x_{ijf}$ represent a binary variable that equals one if the edge $(i,j) \in E$ is utilized in failure scenario $f \in F$, and zero otherwise.
For any user $u \in V_{\rm{U}}$ and server $s \in V_{\rm{S}}$, and for each failure scenario $f \in F$, the relation $x_{usf} \le y_{sf}$ holds. 
Similarly, for any pair of servers $s, t \in V_{\rm{S}}$ with $s \neq t$, and for each $f \in F$, we have $x_{stf} \le y_{sf}$ and $x_{stf} \le y_{tf}$. 
Let $D_{\mathrm{U}f}$ be the largest $d(u,s)$ among all $(u,s) \in E_{\rm{U}}$ used in scenario $f \in F$.
Let $D$ represent the largest total delay of $2D_{\mathrm{U}f}$ taken over all possible failure scenarios.
We define OSA-PSO as an optimization problem aimed at minimizing $D$.
% 
\begin{table}[tb]
    \centering
    \caption{Given parameters and decision parameters of OSA-PSO.}
    \label{tbl:notation_OSA-PSO}
    \begin{tabular}{p{1.3cm}|cp{5.4cm}}
        \hline
        \small
        Given & $V$ & Set of nodes. \\
        parameters & $V_{\rm{U}}$ & Set of users. \\
        & $V_{\rm{S}}$ & Set of potential server locations. \\
        & $E$ & Set of edges. \\
        & $E_{\rm{U}}$ & Set of edges between users and servers. \\
        & $E_{\rm{S}}$ & Set of edges between servers. \\
        & $M_s$ & Maximum number of users that can be assigned to server $s \in V_{\rm{S}}$. \\
        & $d(u,s)$ & Delay between user~$u \in V_{\rm{U}}$ and $s \in V_{\rm{S}}$. \\
        & $d(s,t)$ & Delay between server~$s \in V_{\rm{S}}$ and $t \in V_{\rm{S}}$. \\ 
        & $F$ & Set of possible failure scenarios, where $f = 0$ corresponds to the scenario with no server failure, and each $f \in F \setminus \{0\}$ corresponds to the failure of server~$f$. \\
        & $H_{\rm APL}$ & Maximum status holding time of an application. \\
        & $H_s$ & Maximum status holding time of server $s$. \\ \hline
        Decision parameters & $D$ & The largest total delay of $2D_{\mathrm{U}f}$ taken over all possible failure scenarios. \\
        & $D_{\mathrm{U}f}$ & Largest $d(u,s)$ among all $(u,s) \in E_{\rm{U}}$ used in scenario $f \in F$. \\
        & $x_{ijf}$ & Binary. $x_{ijf} = 1$ if edge $(i,j) \in E_{\rm U} \cup E_{\rm S} (=E)$ is used under failure scenario~$f \in F$; $x_{ijf} = 0$ otherwise. \\
        & $y_{sf}$ & Binary. $y_{sf} = 1$ if server~$s \in V_{\rm{S}}$ is selected under failure scenario~$f \in F$; $y_{sf} = 0$ otherwise. \\ \hline
    \end{tabular}
\end{table}
Table~\ref{tbl:notation_OSA-PSO} summarizes the given parameters and decision parameters used in the problem.

% \vspace{-0.5cm}
\subsection{Formulation of optimization problem}
The optimization problem of OSA-PSO to minimize $D$ is formulated as an ILP problem as follows:
\begin{subequations} \label{OSA-PSO}
  \begin{align}
  \text{Objective}&\text{ min}\quad D \label{OSA-PSO_a} \\
  \rm{s.t.} \quad
  &\sum_{s \in V_{\rm{S}} \setminus \{f\}} x_{usf} = 1, \quad \forall u \in V_{\rm{U}}, \; f \in F \label{OSA-PSO_b} \\
  &\sum_{u \in V_{\rm{U}}} x_{usf} = M_s, \quad \forall s \in V_{\rm{S}}, \; f \in F \label{OSA-PSO_b'} \\  %近似アルゴリズムを考えないので，定式化ではサーバ容量制限も加えた．
  % &\sum_{u \in V_{\rm{U}}} x_{usf} = 0, \quad \mathrm{if} \; s = f, \; \forall f \in F \label{OSA-PSO_c} \\  % これだとOSAではうまくいかない．x_{usf}は0だが，y_{sf}が1となるということが起こってしまう．おそらく，x_{stf}がどこの制約も受けないから．
  &y_{sf} = 0, \quad \mathrm{if} \; s = f, \; \forall f \in F \label{OSA-PSO_c} \\  % これと(h)で，元の(c)式を満たす．さらに，これと(j)でx_{ftf}が0になり，上記のようなことは起こらなくなる（f=0に関しては）．他のfの時も含めて，おかしいのは新たに追加した(l)式で十分だと思うが，元の(c)式よりこちらの方が簡単なのでこのままにしておく．
  &x_{usf}d(u,s) \le D_{\mathrm{U}f}, \quad \forall (u,s) \in E_{\rm{U}}, \; f \in F \label{OSA-PSO_d} \\
  &2D_{\mathrm{U}f} \le D, \quad \forall f \in F \label{OSA-PSO_e} \\
  &x_{us0} \le x_{usf}, \notag \\
  &\qquad \forall f \in F \setminus \{0\}, \; u \in V_{\rm{U}}, \; s \in V_{\rm{S}} \setminus \{f\} \label{OSA-PSO_f} \\
  &x_{usf}d(u,s) + x_{stf}d(s,t) \le \min(H_{\rm APL},H_s), \notag \\
  &\qquad \forall s \in V_{\rm{S}}, (u,s) \in E_{\rm{U}}, (s,t) \in E_{\rm{S}}, f \in F \label{OSA-PSO_g} \\
  &y_{sf} \geq x_{usf}, \quad \forall (u,s) \in E_{\rm{U}}, \; f \in F \label{OSA-PSO_h} \\
  &y_{sf} + y_{tf} - 1 \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{OSA-PSO_i} \\
  &x_{stf} \le y_{sf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{OSA-PSO_j} \\
  &x_{stf} \le y_{tf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{OSA-PSO_k} \\
  &\sum_{u \in V_{\rm{U}}} x_{usf} \geq y_{sf} , \quad \forall s \in V_{\rm{S}}, \; f \in F \label{OSA-PSO_l} \\
  &x_{ijf} \in \{0,1\}, \quad \forall (i,j) \in E, \; f \in F \label{OSA-PSO_m} \\
  &y_{sf} \in \{0,1\}, \quad \forall s \in V_{\rm{S}}, \; f \in F. \label{OSA-PSO_n}
  \end{align}
\end{subequations}
% The optimization problem of CMND-PSO to minimize $D$ is formulated as an ILP problem as follows:
% \begin{subequations} \label{single-failure-without-capacity}
%   \begin{align}
%   \text{Objective}&\text{ min}\quad D \label{SFNC a} \\
%   \rm{s.t.} \quad
%   &\sum_{s \in V_{\rm{S}} \setminus \{f\}} x_{usf} = 1, \quad \forall u \in V_{\rm{U}}, \; f \in F \label{SFNC b} \\
%   &\sum_{u \in V_{\rm{U}}} x_{usf} = 0, \quad \mathrm{if} \; s = f, \; \forall f \in F \label{SFNC d} \\
%   &x_{usf}d(u,s) \le D_{\mathrm{U}f}, \quad \forall (u,s) \in E_{\rm{U}}, \; f \in F \label{SFNC e} \\
%   &x_{stf}d(s,t) \le D_{\mathrm{S}f}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC f} \\
%   &z_{stf}d(s,t) \le L_f, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC g} \\
%   &2D_{\mathrm{U}f}+D_{\mathrm{S}f}+L_f \le D, \quad \forall f \in F \label{SFNC h} \\
%   &x_{us0} \le x_{usf}, \notag \\
%   &\qquad \forall f \in F \setminus \{0\}, \; u \in V_{\rm{U}}, \; s \in V_{\rm{S}} \setminus \{f\} \label{SFNC i} \\
%   &y_{sf} \geq x_{usf}, \quad \forall (u,s) \in E_{\rm{U}}, \; f \in F \label{SFNC k} \\
%   &y_{sf} + y_{tf} - 1 \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC l} \\
%   &x_{stf} \le y_{sf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC m} \\
%   &x_{stf} \le y_{tf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC n} \\
%   &\sum_{s \in V_{\rm{S}} \setminus \{f\}} y_{sf} \geq N_{\rm{SS}} + 1, \quad \forall f \in F \label{SFNC o} \\
%   &z_{stf} \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC p} \\
%   &\sum_{t: \: (s,t) \in E_{\rm{S}}} z_{stf} = y_{sf} N_{\rm{SS}}, \notag \\
%   &\qquad \forall f \in F, \; s \in V_{\rm{S}} \setminus \{f\} \label{SFNC q} \\ % 7/19(金)前田くんのミーティングで，j:の後スペース開けるらしい
%   &\sum_{t: \: (s,t) \in E_{\rm{S}}} z_{stf} = 0, \quad \mathrm{if} \; s = f, \; \forall f \in F \label{SFNC r} \\
%   &\sum_{s: \: (s,t) \in E_{\rm{S}}} z_{stf} = 0, \quad \mathrm{if} \; t = f, \; \forall f \in F \label{SFNC s} \\
%   &x_{ijf} \in \{0,1\}, \quad \forall (i,j) \in E, \; f \in F \label{SFNC t} \\
%   &y_{sf} \in \{0,1\}, \quad \forall s \in V_{\rm{S}}, \; f \in F \label{SFNC u} \\
%   &z_{stf} \in \{0,1\}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F. \label{SFNC v}
%   \end{align}
% \end{subequations}

% \vspace{-0.3cm}
The formulation given in~\eqref{OSA-PSO_a}--\eqref{OSA-PSO_n} is described below.
Equation~\eqref{OSA-PSO_a} defines the objective function, aiming to minimize the largest total delay across all possible failure scenarios.
Equation~\eqref{OSA-PSO_b} ensures that, for every failure scenario, each user is connected to exactly one non-failed server.
Equation~\eqref{OSA-PSO_b'} ensures that, for every server in each failure scenario, the number of users assigned to that server does not exceed its capacity.
Equation~\eqref{OSA-PSO_c} indicates that if a server fails in a failure scenario, it is used.
% indicates that a failed server cannot host any user under each failure scenario.
%
Equation~\eqref{OSA-PSO_d} computes $D_{\mathrm{U}f}$ as the maximum delay from any user to its assigned server in each failure scenario~$f$. %\magenta{We note that~\eqref{OSA-PSO_c} and~\eqref{OSA-PSO_d} can be combined into a single expression: $2 x_{usf}d(u,s) \le D, \quad \forall (u,s) \in E_{\rm{U}}, \; f \in F$; To explicitly identify the meaning of $D_{\mathrm{U}f}$, we keep the expression of~\eqref{OSA-PSO_c} and~\eqref{OSA-PSO_d}.}
Equation~\eqref{OSA-PSO_e} calculates $D$ as the largest total delay of $2D_{\mathrm{U}f}$ across all possible failure scenarios.
% あるサーバがあるfailure scenarioにおいて故障していない場合，どのサーバも故障していないscenarioにおいてそのサーバに接続していたユーザはそのサーバに接続し続ける．
Equation~\eqref{OSA-PSO_f} ensures that, for any server that remains operational in a given failure scenario, users originally assigned to that server when no failures occur are not reassigned elsewhere.
Equation~\eqref{OSA-PSO_g} ensures that, for every server $s \in V_{\rm{S}}$, the maximum status holding time does not surpass the minimum of $H_{\rm APL}$ and $H_s$.
Equation~\eqref{OSA-PSO_h} guarantees that a server is considered active if it serves at least one user.
Equations~\eqref{OSA-PSO_i}--\eqref{OSA-PSO_k} indicates $x_{stf} = y_{sf} \cdot y_{tf}$.
Equation~\eqref{OSA-PSO_l} ensures that at least one user is assigned to a server used in each failure scenario. Equations~\eqref{OSA-PSO_m} and~\eqref{OSA-PSO_n} express the range of decision variables $x_{ijf}$ and $y_{sf}$, respectively.

Since the optimization problem in~\eqref{OSA-PSO_a}--\eqref{OSA-PSO_n} is an ILP problem, we handle it by using an available ILP solver such as CPLEX~\cite{CPLEX}, Gurobi~\cite{Gurobi}, SCIP~\cite{SCIP}, and GLPK~\cite{GLPK}.
% 元の分散処理の定式化でy_ffが選ばれないようになってる？
% zについても同様のこと考慮できてる？

% \vspace{-0.3cm}
\section{NP-completeness}
\label{sec:NP-Completeness}

We define the decision version of the OSA-based server allocation with PSO (D-OSA-PSO) as follows.
\begin{definition}
    Given a set of servers $V_{\rm{S}}$, a set of users $V_{\rm{U}}$, delay values between servers and between servers and users, the maximum number of users that can be assigned to each server $M_s, s \in V_{\rm{S}}$, a set of failure scenarios $F$, where at most one server in $V_{\rm{S}}$ may fail at any time, 
    and the maximum status holding times, $H_{\rm APL}$ and $H_s$ of an application and server $s \in V_{\rm{S}}$, respectively, 
    is there a feasible allocation of users to servers such that the largest total delay $D$ defined in \eqref{OSA-PSO_a} does not exceed $h$, i.e., $D \leq h$, while satisfying the condition that, for every server $s \in V_{\rm{S}}$, the required status holding time does not exceed the minimum of $H_{\rm APL}$ and $H_s$?
\end{definition}
\begin{thm}
D-OSA-PSO is NP-complete.
\end{thm}
\begin{proof}
  First, we show that D-OSA-PSO is in NP.
  % D-OSA-PSOのinstanceが与えられた時，その解がyes instanceかどうかを多項式時間で確認できる．
  Given a certificate of any instance of D-OSA-PSO, we can verify whether the solution is yes in polynomial time.  % 大木先生に25/01/30に送っていただいた本を参考にした．その本は間違ってないから，それに倣っていたら良いはず．
  For each failure scenario $f \in F$, verifying that every user is allocated to a server and determining the maximum user-to-server delay $D_{\mathrm{U}f}$ can be accomplished in $O(|V_{\rm{U}}|)$ time.
  We can verify if the constraint of the maximum status holding time is satisfied in $O(|V_{\rm{U}}||V_{\rm{S}}|)$ time by checking the delay between each user and its assigned server, and the delay between each pair of servers.
  We can also verify whether the total delay under failure scenario $f \in F$, $2D_{\mathrm{U}f}$, is less than or equal to $h$ in $O(1)$ time.
  Since the number of failure scenarios is $|V_{\rm{S}}|+1$, the whole time complexity is $O(|V_{\rm{U}}||V_{\rm{S}}|^2)$.

  Second, we prove that the 3-satisfiability problem (3-SAT), a well-known NP-complete problem~\cite{3_12_3SAT}, can be reduced to D-OSA-PSO in polynomial time. 
  3-SAT is defined as follows:
  {\it Given $n$ boolean variables and $k$ clauses, where each clause consists of three literals, does there exist an assignment of truth values to the variables such that every clause evaluates to true?}

  Given any instance $I$ of 3-SAT, we construct an instance $J$ of D-OSA-PSO. This construction ensures that $I$ is a yes-instance if and only if $J$ is a yes-instance. %M1前期火1L13参考にした
  A schematic diagram illustrating this construction is provided in Fig.~\ref{fig:3SAT_RTC}.
  \begin{figure}[!t]
    \begin{center}
      \includegraphics[width=0.8\columnwidth]{./fig/fig_3SAT_RTC.pdf}
    \end{center}
      % \vspace{-0.3cm}
    \caption{Graph $G$ corresponding to 3-SAT with three clauses.}
    \label{fig:3SAT_RTC}
  \end{figure}

  \begin{itemize}
    \item Create a graph $G$ consisting of $k$ user nodes and $3k+1$ server nodes. The server nodes are consists of a server node $V_{\rm Z}$ and $3k$ server nodes grouped into $k$ sets, each containing three nodes $V_{ij}$ for $i = 1, 2, \cdots, k$ and $j = 1, 2, 3$, 
    \item All server nodes are linked with edges.
    \begin{itemize}
      \item The length of edges between $V_{ij}$ and $V_{i'j'}$ are set to one whenever $i \neq i'$, and $V_{ij}$ and $V_{i'j'}$ are not negations to each other, which means that the edge represents two nodes corresponding to elements that have a compatible true assignment.
      \item Each length of edges between $V_{\rm Z}$ and $V_{ij}$ is set to one.
      \item Otherwise, the length of edges is set to two.
    \end{itemize}
    \item Each user node is linked with edges that have a length of zero.
    \item We set $M_s = H_s = 1$ for all servers $s \in V_{\rm S}$, and $H_{\rm APL} = 1$. Thus, for every $s \in V_{\rm S}$, we have $\min(H_{\rm APL}, H_s) = 1$.
    \item We set the total delay threshold to $h = 2$.
  \end{itemize}
The above construction can be performed in time $O(|E_{\rm S}| + |E_{\rm U}|)$.


The D-OSA-PSO instance is feasible if and only if there exists a satisfiable 3-SAT assignment, which is shown below.

Suppose that there exists a true 3-SAT assignment. 
We consider three cases for at most one server failure in the following.
First, if server node $V_{\rm Z}$ fails, we can choose $k$ nodes from $V_{ij}$, one corresponding to a true assignment from each clause, which are all interconnected with edges of length one.
We can assign the $k$ user nodes to the $k$ selected server nodes under this failure scenario.
Since no edge with a length greater than one in $G$ is used and edges between user nodes and server nodes have a length of zero, $2D_{\mathrm{U}f}$  is two, and the required status holding time is one.
Second, if a server node $V_{ij}$ fails, we can reassign the user nodes assigned to the failed server node to server node $V_{\rm Z}$, which ensures that $2D_{\mathrm{U}f}$ is two and the required status holding time is one.
Third, if no server fails, we can assign each user node to the same server node as in the case where server node $V_{\rm Z}$ fails, which also ensures that $2D_{\mathrm{U}f}$ is two and the required status holding time is one.
Hence, the largest total delay $D = \max_{f \in F}{2D_{\mathrm{U}f}}$ is two, which satisfies $D \leq h$, and the required status holding time among all server failure scenarios is one.
Therefore, the D-OSA-PSO instance is feasible.

Conversely, assume that an instance of D-OSA-PSO is yes.
When server node $V_{\rm Z}$ fails, there exists a set of $k$ fully interconnected server nodes with edges of length one between $V_{ij}$.
From the definition of $G$, these server nodes correspond to variables with compatible true assignments.
Thus, assigning the value true to the variables associated with these $k$ nodes ensures that every clause is satisfied.
Therefore, the corresponding instance of 3-SAT is yes.

Since we have shown a polynomial-time reduction from 3-SAT to D-OSA-PSO, and D-OSA-PSO is in NP, it follows that D-OSA-PSO is NP-complete.
\end{proof}

% \vspace{-0.3cm}
\section{Numerical results}
\label{sec:numerical_results}
We evaluate the proposed model in terms of OSA and PSO.
% 
For our experiments, we consider two networks: the JPN Kanto region~\cite{JPN} and COST~239~\cite{COST}. 
The potential servers in each network are illustrated in Fig.~\ref{fig:ServerLocation}.
In each network, servers are interconnected using the shortest available path.
For instance, in the COST~239 network, node~6 reaches node~11 through node~9.
In each network, user locations are randomly generated within the latitude and longitude ranges indicated in Fig.~\ref{fig:ServerLocation}.
The delay is assumed to increase linearly with transmission distance, with a reference value of 0.5~ms per 100~km, following the approach in~\cite{KawabataICC2023}.
Distances for direct links between servers and links between servers and users are computed using spherical trigonometry based on geographic coordinates, as described in~\cite{12Imanaka2024}.
The distance $d_\mathrm{AB}$ between two locations A and B, given their longitudes $x_\mathrm{A}$, $x_\mathrm{B}$ and latitudes $y_\mathrm{A}$, $y_\mathrm{B}$, is computed as follows:
$d_\mathrm{AB} = R \arccos\left( \sin y_\mathrm{A} \sin y_\mathrm{B} + \cos y_\mathrm{A} \cos y_\mathrm{B} \cos(x_\mathrm{A} - x_\mathrm{B}) \right)$,
where $R$ denotes the equatorial radius~\cite{Zohora2018}.
All experiments are performed on a PC with an Intel(R) Core(TM) i7-7700 3.60~GHz processor and 32 GB of memory.
We solve ILP problems using CPLEX 12.10.0.0~\cite{CPLEX}.
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.47\columnwidth]{./fig/server_location_JPN_tight_fontsize22_fonttypeType1_OSA.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/server_location_COST_tight_fontsize22_fonttypeType1_OSA.pdf} \\
      (a) JPN Kanto & (b) COST~239
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{Potential server locations in JPN Kanto and COST~239.}
  \label{fig:ServerLocation}
\end{figure}

We conduct experiments by solving the ILP problem~\eqref{OSA-PSO_a}--\eqref{OSA-PSO_n} in the proposed model, where $H_{\rm APL}$ and $H_s$ are fixed to given values, and the number of users is varied from 30 to 70 in steps of 10.
% server capacityの制限はなしで行う
We set $M_s$ to $V_{\rm U}$, which means that each server can accommodate all users; we observe the basic characteristics of the proposed model, eliminating the impact of server capacity in this paper.
For each configuration, we perform $n$ independent trials.
We set $n$ to 20 for all configurations
and use the average of the results.

\subsection{Dependency on maximum status holding time}
\label{subsec:Dependency_on_maximum_status_holding_time}

We assess the delay and the computation times of OSA-PSO and the conventional model, which is a CSA-based server allocation model with PSO (CSA-PSO), depending on the maximum status holding time, $H_{\rm APL}$ and $H_s$.
CSA-PSO is formulated as follows:
\begin{subequations} \label{CSA-PSO}
  \begin{align}
  \text{Objective}&\text{ min}\quad D \label{CSA-PSO_a} \\
  \rm{s.t.} \quad
  & \eqref{OSA-PSO_b}-\eqref{OSA-PSO_e}, \eqref{OSA-PSO_g}, \eqref{OSA-PSO_i}-\eqref{OSA-PSO_n} \label{CSA-PSO_b} \\
  &x_{stf}d(s,t) \le D_{\mathrm{S}f}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{CSA-PSO_c} \\
  &2D_{\mathrm{U}f} + D_{\mathrm{S}f} \leq D, \quad \forall f \in F. \label{CSA-PSO_d}
  \end{align}
\end{subequations}

\subsubsection{Impact of $H_{\rm APL}$}

For the evaluation focusing on the application maximum status holding time, we set $H_s$ to $H_{\rm APL}$.
$H_{\rm APL}$ is set from 0.8~ms to 1.3~ms for JPN Kanto and from 7.0~ms to 12.0~ms for COST~239.

% ここからdelayの評価
Figs.~\ref{fig:delay_OSA_CSA_hapl_JPN} and~\ref{fig:delay_OSA_CSA_hapl_COST} show how the delay varies when $H_{\rm APL}$ changes for both the proposed and conventional models in the JPN Kanto and COST~239 networks, respectively.
The delay of OSA decreases as $H_{\rm APL}$ increases for both networks.
When $H_{\rm APL} \geq 0.9$~ms for JPN Kanto and $H_{\rm APL} \geq 8.0$~ms for COST~239, the delay of OSA is lower than that of CSA.
% h_aplが大きい時にCSAの何%以下と言う記述はしないでおく．（%があまり低くないし，あまりダラダラ書いてられない）
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hapl_JPN_numU30_15_fonttypeType1.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hapl_JPN_numU70_15_fonttypeType1.pdf} \\
      (a) 30 users & (b) 70 users
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{Delay for JPN Kanto when $|V_{\rm U}| = 30, 70$ depending on $H_{\rm APL}$.}
  \label{fig:delay_OSA_CSA_hapl_JPN}
\end{figure}
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hapl_COST_numU30_12_fonttypeType1.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hapl_COST_numU70_12_fonttypeType1.pdf} \\
      (a) 30 users & (b) 70 users
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{Delay for COST~239 when $|V_{\rm U}| = 30, 70$ depending on $H_{\rm APL}$.}
  \label{fig:delay_OSA_CSA_hapl_COST}
\end{figure}
When $H_{\rm APL}$ is reduced, assigning each user to their closest server may violate the maximum status holding time constraint specified in~\eqref{OSA-PSO_g}.
% ユーザ-サーバ間の遅延が少し増えたとしても，最も遠いサーバとの遅延である$x_{usf}d(u,s) + x_{stf}d(s,t)$が小さくなるようなサーバを選択する必要がある．（川端先生の助言を受けて修正）
%\blue{a user $u$ must select a server $s$ that reduces the delay to the farthest server $t$, $x_{usf}d(u,s) + x_{stf}d(s,t)$, even if it results in a slight increase in the user-server delay $x_{usf}d(u,s)$}.
In such cases, a user~$u$ restricted by~\eqref{OSA-PSO_g} must select a more distant server $s$ while minimizing the objective value in~\eqref{OSA-PSO_a}, which results in a slight increase in the user-server delay $x_{usf}d(u,s)$.
This results in an increase in $D_{\mathrm{U}f}$, leading to a larger delay for OSA.
Figs.~\ref{fig:delay_OSA_CSA_hapl_JPN} and~\ref{fig:delay_OSA_CSA_hapl_COST} show that the delay values for 30 and 70 users are quite similar.
This is because the overall delay is determined by the user-server pair with the maximum distance; thus, the location of the most distant user becomes the dominant factor in the total delay.
As a result, when the farthest users in both the 30-user and 70-user cases are located at comparable distances from the servers, the maximum delay remains nearly unchanged.
% ユーザ数やネットワークトポロジによらず、\min(H_{\rm APL}, H_s)の許容値が大きくなることで、$x_{usf}d(u,s) + x_{stf}d(s,t)$の最大値を決定づけるユーザがより近いサーバを選択可能（2D_{\mathrm{U}f}を小さくできる）となる．（川端先生の助言で追加）
Regardless of the number of users or the network topology, increasing an admissible value for $\min(H_{\rm APL}, H_s)$ allows the user that determines the maximum value of $x_{usf}d(u,s) + x_{stf}d(s,t)$ to select a closer server, thereby reducing $2D_{\mathrm{U}f}$.
From the above results, it can be concluded that regardless of the number of users or the network topology, the proposed OSA-PSO model is effective in reducing delay when $H_{\rm APL}$ is large.

% ここからcomputation timeの評価
Tables~\ref{tab:ComputationTime_OSA_CSA_hapl_JPN} and~\ref{tab:ComputationTime_OSA_CSA_hapl_COST} show computation time for OSA and CSA at JPN Kanto and COST~239, respectively.
When $V_{\rm U} = 30, 40, 50$ at COST~239, the computation time of OSA is shorter than that of CSA.
When $V_{\rm U} = 60, 70$ at COST~239, the computation time of OSA at $H_{\rm APL} = 8.0$~ms is longer than that of CSA but shorter than that of CSA at other $H_{\rm APL}$ values.
In both networks, as the difference from a certain value of $H_{\rm APL}$ increases, the computation time tends to decrease.
% 近似アルゴリズムを今回は考えないので，以下のブロックを追加
For scenarios with up to 70 users, the computation time remains within a few minutes, depending on the network topology and the value of $H_{\rm APL}$. 
In practical situations, a short wait of several minutes before service initiation is permissible.
Since user locations are typically known beforehand, this computation can be performed prior to launching the application, making the required processing time acceptable.
\begin{table}[t]
  \caption{Comparison of computation time for each model at JPN Kanto.}
  \label{tab:ComputationTime_OSA_CSA_hapl_JPN}
  \begin{center}
    \begin{tabular}{c|cccccc|c}
      \hline
      $|V_{\rm{U}}|$ & \multicolumn{6}{c|}{OSA [s]} & CSA [s] \\ \cline{2-7}
       & \multicolumn{6}{c|}{$H_{\rm{APL}}$ [ms]} & \\
       & 0.8 & 0.9 & 1.0 & 1.1 & 1.2 & 1.3 &  \\
      \hline
      % \hline
      30 & 1.2 &  4.7 &  5.9 &  4.4 &  1.5 &  1.2 &  4.3 \\
      40 & 1.4 &  7.2 &  9.1 &  8.0 &  4.9 &  2.0 &  7.4 \\
      50 & 1.7 & 10.0 & 13.6 & 11.5 &  9.2 &  5.3 & 10.4 \\
      60 & 1.8 & 15.8 & 18.5 & 16.8 & 11.5 &  8.1 & 14.4 \\
      70 & 1.6 & 24.7 & 28.7 & 24.5 & 19.6 & 12.5 & 22.4 \\
      \hline
    \end{tabular}
  \end{center}
\end{table}
\begin{table}[t]
  \caption{Comparison of computation time for each model at COST~239.}
  \label{tab:ComputationTime_OSA_CSA_hapl_COST}
  \begin{center}
    \begin{tabular}{c|cccccc|c}
      \hline
      $|V_{\rm{U}}|$ & \multicolumn{6}{c|}{OSA [s]} & CSA [s] \\ \cline{2-7}
       & \multicolumn{6}{c|}{$H_{\rm{APL}}$ [ms]} & \\
       & 7.0 & 8.0 & 9.0 & 10.0 & 11.0 & 12.0 &  \\
      \hline
      % \hline
      30 & 19.1 &  24.1 &  8.7 &  6.3 &  3.8 &  3.8 &  27.6 \\
      40 & 33.2 &  44.8 & 17.9 & 11.0 &  5.9 &  3.8 &  47.3 \\
      50 & 55.1 &  72.7 & 31.7 & 13.4 & 10.4 &  5.9 &  86.4 \\
      60 & 67.8 & 150.7 & 61.6 & 22.6 & 18.9 & 10.9 &  84.9 \\
      70 & 82.2 & 201.0 & 91.4 & 30.5 & 15.5 & 29.1 & 112.7 \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

\subsubsection{Impact of $H_s$}
For the evaluation focusing on the server maximum status holding time, we set $H_{\rm APL}$ to the maximum value of $H_s$.
In this evaluation, we investigate whether increasing the number of servers with higher $H_s$ values (i.e., those with greater memory resources) can result in a reduction in delay.
We set values of $H_s$ for JPN Kanto and COST~239, as shown in Table~\ref{tab:condition_hs_JPN_COST}.
\begin{table}[t]
  \caption{Values of $H_s$ defined in JPN Kanto and COST~239.}
  \label{tab:condition_hs_JPN_COST}
  \begin{center}
    \begin{tabular}{c|c}
      \hline
      JPN-A & $0.8,\; \forall s \in V_{\rm S}$ \\
      JPN-B & $0.8\,(s=1,3,4,5,7,8),\;1.0\,(s=2,6)$ \\
      JPN-C & $0.8\,(s=1,3,5,7),\;1.0\,(s=2,4,6,8)$ \\
      \hline
      COST-A & $7.0,\; \forall s \in V_{\rm S}$ \\
      COST-B & $7.0\,(s=1,2,3,4,5,7,8,9,10,11),\;9.0\,(s=6,8)$ \\
      COST-C & $7.0\,(s=1,3,5,7,8,9,10,11),\;9.0\,(s=2,4,6,8)$ \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

Figs.~\ref{fig:delay_OSA_CSA_hs_JPN} and~\ref{fig:delay_OSA_CSA_hs_COST} show how the delay varies when $H_s$ changes for both the proposed and conventional models in the JPN Kanto and COST~239 networks, respectively.
Figs.~\ref{fig:delay_OSA_CSA_hs_JPN} and~\ref{fig:delay_OSA_CSA_hs_COST} demonstrate that increasing the number of servers with greater memory resources leads to lower delays. 
These findings suggest that the proposed model effectively utilizes server memory resources to minimize delay.
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hs_JPN_numU30_15_fonttypeType1.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hs_JPN_numU70_15_fonttypeType1.pdf} \\
      (a) 30 users & (b) 70 users
      \end{tabular}
  \end{center}
       \vspace{-0.2cm}
  \caption{Delay for JPN Kanto when $|V_{\rm U}| = 30, 70$ depending on $H_s$.}
  \label{fig:delay_OSA_CSA_hs_JPN}
\end{figure}
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hs_COST_numU30_12_fonttypeType1.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hs_COST_numU70_12_fonttypeType1.pdf} \\
      (a) 30 users & (b) 70 users
      \end{tabular}
  \end{center}
       \vspace{-0.2cm}
  \caption{Delay for COST~239 when $|V_{\rm U}| = 30, 70$ depending on $H_s$.}
  \label{fig:delay_OSA_CSA_hs_COST}
\end{figure}

% \vspace{-0.3cm}
\subsection{Comparison of proposed PSO model with SO and RO}
To demonstrate the effectiveness of PSO, we compare our proposed model against two baselines.
We evaluate the performance as the number of users varies, using both the JPN Kanto region and COST~239 networks.
We set $H_{\rm APL} = H_s = 1.1$~ms in JPN Kanto and $H_{\rm APL} = H_s = 10$~ms in COST~239.

\subsubsection{Baselines}
We consider two baselines: SO and RO.
Both methods first compute the assignment to minimize the total delay, assuming no server failures.
When a server failure occurs, they then determine the reassignment for the affected scenario.
% Specifically, SO reallocates only those users whose server has failed to available servers to minimize the total delay in that scenario;
% RO reassigns all users to non-failed servers to minimize the total delay under this failure scenario.

For SO and RO, we first solve the ILP problem formulated as follows:
\begin{subequations} \label{OSA-SO-f0}
  \begin{align}
  \text{Objective}&\text{ min}\quad 2D_{\mathrm{U}f} \label{OSA-SO-f0_a} \\
  \rm{s.t.} \quad
  & \eqref{OSA-PSO_b}, \eqref{OSA-PSO_d}, \eqref{OSA-PSO_g}-\eqref{OSA-PSO_n}, \; F = \{0\}. \label{OSA-SO-f0_b}
  \end{align}
\end{subequations}
This gives us the assignment under the scenario where no server fails, expressed as $x^0_{us}$ for $(u,s) \in E_{\rm{U}}$.

For the next step for SO, we solve the optimization problem for each failure scenario $f \in F \setminus \{0\}$ formulated as follows:
\begin{subequations} \label{OSA-SO}
  \begin{align}
  \text{Objective}&\text{ min}\quad D^f \label{OSA-SO_a} \\
  \rm{s.t.} \quad
  % ------ 省略部分開始 ------
  & \eqref{OSA-PSO_b}-\eqref{OSA-PSO_d}, \eqref{OSA-PSO_g}-\eqref{OSA-PSO_n}, \; F = \{f\} \label{OSA-SO_b-d,g-n} \\
  % ------ 省略部分終了 ------
  &2D_{\mathrm{U}f} \le D^f \label{OSA-SO_h} \\
  &x^0_{us} \le x_{usf}, \quad \forall u \in V_{\rm{U}}, \; s \in V_{\rm{S}} \setminus \{f\}. \label{OSA-SO_i}
  \end{align}
\end{subequations}
% \begin{subequations} \label{SO}
%   \begin{align}
%   \text{Objective}&\text{ min}\quad D^f \label{SO a} \\
%   \rm{s.t.} \quad
%   % &\sum_{s \in V_{\rm{S}} \setminus \{f\}} x_{usf} = 1, \quad \forall u \in V_{\rm{U}}, \label{SO b} \\
%   % % &\red{\sum_{u \in V_{\rm{U}}} x_{usf} \le C_{s}, \quad \forall f \in F, \; s \in V_{\rm{S}} \setminus \{f\}} \label{SO c} \\
%   % &\sum_{u \in V_{\rm{U}}} x_{usf} = 0, \quad \mathrm{if} \; s = f, \label{SO d} \\
%   % &x_{usf}d(u,s) \le D_{\mathrm{U}f}, \quad \forall (u,s) \in E_{\rm{U}}, \label{SO e} \\
%   % &x_{stf}d(s,t) \le D_{\mathrm{S}f}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO f} \\
%   % &z_{stf}d(s,t) \le L_f, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO g} \\
%   % ------ 省略部分1開始 ------
%   & \eqref{SFNC b}-\eqref{SFNC g}, \; F = \{f\}, \label{SO b-g} \\
%   % ------ 省略部分1終了 ------
%   &2D_{\mathrm{U}f}+D_{\mathrm{S}f}+L_f \le D^f, \label{SO h} \\
%   &x^0_{us} \le x_{usf}, \quad \forall u \in V_{\rm{U}}, \; s \in V_{\rm{S}} \setminus \{f\} \label{SO i} \\
%   % % &\red{z_{st0} \le z_{stf},} \notag \\
%   % % &\red{\quad \forall f \in F \setminus \{0\}, \; s,t \in V_{\rm{S}} \setminus \{f\}, (s,t) \in E_{\rm{S}}} \label{SO j} \\
%   % &y_{sf} \geq x_{usf}, \quad \forall (u,s) \in E_{\rm{U}}, \label{SO k} \\
%   % &y_{sf} + y_{tf} - 1 \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO l} \\
%   % &x_{stf} \le y_{sf}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO m} \\
%   % &x_{stf} \le y_{tf}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO n} \\
%   % &\sum_{s \in V_{\rm{S}} \setminus \{f\}} y_{sf} \geq N_{\rm{SS}} + 1, \label{SO o} \\
%   % &z_{stf} \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO p} \\
%   % &\sum_{t: \: (s,t) \in E_{\rm{S}}} z_{stf} = y_{sf} N_{\rm{SS}}, \quad \forall s \in V_{\rm{S}} \setminus \{f\} \label{SO q} \\ % 7/19(金)前田くんのミーティングで，j:の後スペース開けるらしい
%   % &\sum_{t: \: (s,t) \in E_{\rm{S}}} z_{stf} = 0, \quad \mathrm{if} \; s = f, \label{SO r} \\
%   % &\sum_{s: \: (s,t) \in E_{\rm{S}}} z_{stf} = 0, \quad \mathrm{if} \; t = f, \label{SO s} \\
%   % &x_{ijf} \in \{0,1\}, \quad \forall (i,j) \in E, \label{SO t} \\
%   % &y_{sf} \in \{0,1\}, \quad \forall s \in V_{\rm{S}}, \label{SO u} \\
%   % &z_{stf} \in \{0,1\}, \quad \forall (s,t) \in E_{\rm{S}}. \label{SO v}
%   % ------ 省略部分2開始 ------
%   & \eqref{SFNC k}-\eqref{SFNC v}, \; F = \{f\}. \label{SO k-v}
%   % ------ 省略部分2終了 ------
%   \end{align}
% \end{subequations}
Equation~\eqref{OSA-SO_b-d,g-n} enforces the same constraints as~\eqref{OSA-PSO_b}--\eqref{OSA-PSO_d} and~\eqref{OSA-PSO_g}--\eqref{OSA-PSO_n}, applied for the single failure scenario $F = \{f\}$.
While the SO formulation closely resembles that of PSO, there are notable distinctions between the two approaches.
In PSO, the assignments for all failure scenarios, including the scenario with no server failure, are jointly optimized by solving the ILP formulation~\eqref{OSA-PSO_a}--\eqref{OSA-PSO_n}, treating $x_{us0}$ in~\eqref{OSA-PSO_f} as a variable to be determined.
In contrast, SO first computes the assignment for the no-failure scenario by solving the ILP formulation~\eqref{OSA-SO-f0_a}--\eqref{OSA-SO-f0_b}, and subsequently, for each failure scenario, determines the reassignment by solving the ILP formulation~\eqref{OSA-SO_a}--\eqref{OSA-SO_i}, using the previously obtained $x^0_{us}$ in~\eqref{OSA-SO_i} as a given parameter.
For RO, the optimization problem for each failure scenario $f \in F \setminus \{0\}$ is formulated in the same way as SO, except that constraint~\eqref{OSA-SO_i} is omitted from~\eqref{OSA-SO_a}--\eqref{OSA-SO_i}.

\subsubsection{Experiment setup and metrics}
Following the approach in~\cite{5_9_13_Kamrul2010, 5_9_Masuda2020}, we assess the performance of the proposed model and baselines using the metrics described below.
To evaluate the benefit of PSO over SO, we define the reduction ratio of the largest total delay achieved by PSO compared to SO as
$\alpha = \frac{\max_{f \in F}D^f_{\rm SO} - D_{\rm PSO}}{\max_{f \in F}D^f_{\rm SO}}$.
We further evaluate the extent to which PSO increases the total delay in the no-failure scenario compared to SO. This penalty is calculated as
$\beta = \frac{D^0_{\rm PSO} - D^0_{\rm SO}}{D^0_{\rm SO}}$.

To evaluate the performance of PSO relative to RO, we define the increase ratio of the largest total delay under PSO compared to RO as
$\gamma = \frac{D_{\rm PSO} - \max_{f \in F}D^f_{\rm RO}}{\max_{f \in F}D^f_{\rm RO}}$.
An unnecessary disconnection is defined as the reassignment of a user to a different server when their original server remains operational.
For each failure scenario $f \in F$, let $\nu_f$ denote the proportion of users experiencing such unnecessary disconnections.
% \muは平均として使いたいので，\nuに変更
The average proportion of users who experience unnecessary disconnections, calculated across all failure scenarios, is given by
$\nu = \frac{\sum_{f \in F \setminus \{0\}}\nu_f}{|F| - 1}$.

\subsubsection{Evaluation}
Figs.~\ref{fig:OSA_alpha_beta_JPN} and~\ref{fig:OSA_alpha_beta_COST} illustrate how $\alpha$ and $\beta$ vary as the number of users increases in the JPN Kanto region and COST~239 networks, respectively.
% average: alpha JPN:0.1956 COST:0.0070 total:0.1013, beta JPN:0.3829 COST:0.1048 total:0.2439
It can be observed that $\alpha$ increases as the number of users rises in both networks, indicating that PSO achieves larger reductions in total delay compared to SO as the user count increases.
On average, $\alpha$ is 0.10, with the highest observed value for a failure scenario at one trial being 0.41 in JPN Kanto.
It is observed that $\beta$ tends to decline slightly for $|V_{\rm U}| \geq 40$ in the JPN Kanto, with the overall average value of $\beta$ being 0.24.

\begin{figure}[tb]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/alpha_JPN_hapl_1.1_025_fonttypeType1.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/beta_JPN_hapl_1.1_05_fonttypeType1.pdf} \\
      (a) $\alpha$ & (b) $\beta$
      \end{tabular}
  \end{center}
      \vspace{-0.2cm}
  \caption{Evaluation of PSO with SO when the number of users varies in JPN Kanto region.}
  \label{fig:OSA_alpha_beta_JPN}
\end{figure}

\begin{figure}[tb]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/alpha_COST_hapl_1.1_001_fonttypeType1.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/beta_COST_hapl_10.0_025_fonttypeType1.pdf} \\
      (a) $\alpha$ & (b) $\beta$
      \end{tabular}
  \end{center}
      \vspace{-0.2cm}
  \caption{Evaluation of PSO with SO when the number of users varies in COST~239.}
  \label{fig:OSA_alpha_beta_COST}
\end{figure}

Table~\ref{tab:OSA-PSO_gamma_nu} presents the results for $\gamma$ and $\nu$ as the number of users varies in both the JPN Kanto region and COST~239 networks.
% average value \gamma: JPN:4.267*10e-4, COST:0, total:2.134*10e-4
It is found that the average value of $\gamma$ is $2.1 \times 10^{-4}$, indicating that the largest total delay under PSO exceeds that of RO by only 0.021\% overall.
% average value \nu: JPN:0.448, COST:0.378, total:0.413
On average, $\nu$ is 0.41, indicating that 41\% of users experience unnecessary disconnections per failure scenario when using RO, while PSO completely eliminates such disconnections.
As the number of users grows in both networks, $\nu$ also rises, suggesting that PSO becomes increasingly effective at preventing instability with larger users.
\begin{table}[t]
  \caption{Evaluation of PSO with RO when the number of users varies.}
  \label{tab:OSA-PSO_gamma_nu}
  \begin{center}
    \begin{tabular}{c|cc|cc}
      \hline
      & \multicolumn{2}{c|}{JPN Kanto} & \multicolumn{2}{c}{COST~239} \\ \cline{2-5}
      $|V_{\rm{U}}|$ & $\gamma$ & $\nu$ & $\gamma$ & $\nu$ \\
      \hline
      30 & $3.8 \times 10^{-4}$ & 0.42 & $0.0$ & 0.34 \\
      40 & $4.9 \times 10^{-4}$ & 0.43 & $0.0$ & 0.37 \\
      50 & $4.9 \times 10^{-4}$ & 0.44 & $0.0$ & 0.40 \\
      60 & $3.8 \times 10^{-4}$ & 0.47 & $0.0$ & 0.37 \\
      70 & $3.8 \times 10^{-4}$ & 0.48 & $0.0$ & 0.41 \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

It is found that solving the PSO formulation~\eqref{OSA-PSO_a}--\eqref{OSA-PSO_n} for $|V_{\rm U}|=30$ in COST~239 requires 6.33~[s].
Under the same conditions, SO and RO need $2.96 \times 10^{-2}$~[s] to compute the initial assignment without failures.
For each failure scenario, the reassignment step takes $3.92 \times 10^{-3}$~[s] for SO and $2.39 \times 10^{-2}$~[s] for RO, resulting in total computation times of 0.073~[s] for SO and 0.293~[s] for RO.
These results indicate that PSO requires more computational time than SO and RO, as it simultaneously solves a larger-scale optimization problem.
Additionally, RO is slower than SO because it reassigns all users in each failure scenario, whereas SO only reallocates users whose servers have failed.

% この段落は最終版では外して，extended versionで追加してもいいかも．
% \ref{subsec:Evaluation with maximum status holding time}と同様に$H_{\rm APL}$を変化させて，PSO，SO，ROを実行すると，SOはJPNで$H_{\rm APL} \leq 1.0$，COSTで$H_{\rm APL} \leq 9$のとき，実行可能解が存在しなかった．
We also compare the proposed model and two baselines by varying the maximum status holding time $H_{\rm APL}$ as in~\ref{subsec:Dependency_on_maximum_status_holding_time}.
In this case, SO does not yield a feasible solution for $H_{\rm APL} \leq 1.0$ in JPN Kanto and $H_{\rm APL} \leq 9$ in COST~239.
% これは，maximum status holding timeの制約が厳しくなった際に，SOよりもPSOの方が柔軟に対応することができることを示している．
This indicates that PSO can adapt more flexibly than SO when the maximum status holding time constraint becomes stricter.

Overall, the proposed PSO model achieves a lower largest total delay than SO by jointly optimizing across all failure scenarios, with an average improvement $\alpha$ of 0.10 and up to 0.41 in the worst case.
The largest total delay under PSO is nearly equivalent to that of RO.
Furthermore, PSO effectively eliminates instability due to unnecessary user reassignments, whereas RO results in an average of 41\% of users being unnecessarily reassigned per failure scenario.

% \vspace{-0.5cm}
\section{Conclusion}
\label{sec:conclusion}

We proposed the optimistic synchronization-based server allocation model with preventive start-time optimization (OSA-PSO) against single-server failures.
We formulated the proposed model as an ILP problem, which minimizes the largest total delay across all failure scenarios while satisfying the maximum status holding time constraints.
We proved that the decision version of the problem is NP-complete.
We compared the proposed OSA-PSO model with the conventional conservative synchronization-based server allocation model with PSO (CSA-PSO). We showed that OSA-PSO achieves a lower delay than CSA-PSO when the maximum status holding time is large.
We also compared the proposed OSA-PSO model with two baselines, start-time optimization (SO) and run-time optimization (RO).
The results showed that the proposed model outperforms SO by jointly optimizing across all failure scenarios, achieving 10\% reduction in the largest total delay on average, with a maximum improvement of 41\% in the worst case.
The results also showed that the proposed model achieves the largest total delay, nearly equivalent to that of RO, while eliminating instability due to unnecessary user reassignments, which RO causes in 41\% of users per failure scenario.

\bibliography{IEEEabrv,Oda_optimistic_PSO}

\end{CJK}

\end{document}