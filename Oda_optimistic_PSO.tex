\documentclass[10pt, letterpaper]{IEEEtran}
\usepackage[dvipdfmx]{color}
\usepackage[dvipdfmx]{graphicx}

% 日本語対応のCJKパッケージ
\usepackage{CJKutf8}

%\setlength{\textwidth}{17cm}
%\setlength{\textheight}{25cm}
%\setlength{\topmargin}{-1cm}
%\setlength{\oddsidemargin}{-0.5cm}
%\setlength{\evensidemargin}{1cm}
%\setlength{\voffset}{-1cm}
%\usepackage{flushend}
\setlength\intextsep{0pt}
\setlength\textfloatsep{0pt}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{cite}
\usepackage{url}
%\usepackage{showframe}
\usepackage{subfigure}
%\usepackage{subcaption}
\usepackage{comment}
\usepackage{diagbox}  % 表内でセルを斜めに分割するため．2024/12/18追加

\usepackage{amssymb}
\usepackage{xcolor} %色を変えるために追加
% \usepackage{ulem} % 打ち消し線のため  % 2025/3/25 雑誌名にアンダーラインがつくし，もう不要なのでコメントアウト
% \usepackage{amsthm} % Theoremと表示するため
\usepackage{amsmath,algorithm,float,tabularx,amsfonts} % Algorithm書くため
\usepackage{algpseudocode} % Algorithm書くため
\usepackage{graphics} % \scaleboxを使うため
\newcommand{\multiline}[1]{% 複数行に渡るときに左端を揃えるため
    \begin{tabularx}{\dimexpr\linewidth-\ALG@thistlm}[t]{@{}X@{}}
        #1
    \end{tabularx}
}
\newcommand{\Step}[1]{\algrenewcommand{\alglinenumber}[1]{\textbf{Step ##1.} } #1} % AlgorithmでStep 1. と表示するため
\newcommand{\Stepmini}[1]{\algrenewcommand{\alglinenumber}[1]{\textbf{Step 1-##1.} } #1} % AlgorithmでStep 1-1. と表示するため
\newcommand{\NoNumber}{\algrenewcommand{\alglinenumber}[1]{\setcounter{ALG@line}{\numexpr##1-1} \ \ \ \ \ \ \ \ \ \ }} % Algorithmでインデントつきで改行するため
\newcommand{\AdjustNumber}{\algrenewcommand{\alglinenumber}[1]{\setcounter{ALG@line}{\numexpr##1-2}}} % AlgorithmでStep番号を調整するため
\newcommand{\StartLeft}{\algrenewcommand{\alglinenumber}[1]{\setcounter{ALG@line}{\numexpr##1-1}}} % Algorithmで数式後の文章の始まりを左に揃えるため
% AlgorithmでRequireとEnsureをInputとOutputにする
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\newtheorem{thm}{Theorem} % Theoremと表示するため
\newtheorem{lemma}{Lemma} % Lemmaと表示するため

% \newtheorem{lemma}{Lemma}
\newtheorem*{proof*}{Proof}
% \newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newcommand{\argmin}{\mathop{\rm argmin}\limits}
\renewcommand\thefootnote{\dag}
%\lstset{
%    basicstyle={\ttfamily\small}, %書体の指定
%    frame=tRBl, %フレームの指定
%    framesep=10pt, %フレームと中身（コード）の間隔
%    breaklines=true, %行が長くなった場合の改行
%    linewidth=15cm, %フレームの横幅
%    lineskip=-0.5ex, %行間の調整
%    tabsize=2 %Tabを何文字幅にするかの指定
%}

\newcommand\blue[1]{\textcolor{blue}{#1}}
\newcommand\red[1]{\textcolor{red}{#1}}
\newcommand\cyan[1]{\textcolor{cyan}{#1}}
\newcommand\magenta[1]{\textcolor{magenta}{#1}}
\newcommand\green[1]{\textcolor{green}{#1}}
\newcommand\black[1]{\textcolor{black}{#1}}

\allowdisplaybreaks % 数式がページをまたぐことを許可

\bibliographystyle{IEEEtran} % bibtexのために追加

\begin{document}

\begin{CJK}{UTF8}{ipxm}

\title{\Large
%\red{An Optimistic Synchronization Based Optimal Server Allocation Model for Delay-Sensitive Applications with Preventive Start-Time Optimization under Single-Server Failures}
Optimistic Synchronization-Based Server Allocation with Preventive Start-Time Optimization for Delay-Sensitive Applications under Server Failure
\thanks{This work was supported in part by the Japan Society for the Promotion of Science (JSPS) KAKENHI, under Grant Number 23K28072.}
}
\author{Masaki Oda$^\dag$, Akio Kawabata$^\ddag$, and Eiji Oki$^\dag$\\
$^\dag$Kyoto University, Kyoto, Japan\ \ $^\ddag$Toyohashi University of Technology, Aichi, Japan} 
\maketitle

% \vspace{-2cm}
\begin{abstract}
Real-time applications require low latency and event order guarantees.  
Distributed server processing is effective for this purpose, and data consistency between servers is crucial.  
Although existing models in previous work handle data consistency, they do not address server failures.  
This paper proposes a server allocation model for a consistency-aware multi-server network for delay-sensitive applications with preventive start-time optimization (PSO) under single-server failures.
The proposed model considers data consistency between servers and handles single-server failures with PSO.
PSO determines the assignment to minimize the worst-case delay over all possible failure scenarios while avoiding service disruption for users connected to non-failed servers.  
We formulate the proposed model as an integer linear programming (ILP) problem.  
The decision version of the server allocation problem is proven to be NP-complete, and it becomes difficult to solve in a practical time when the problem size is large.  
We develop two polynomial-time approximation algorithms with theoretical performance analysis. 
Numerical results show that the proposed model outperforms start-time optimization in terms of the largest total delay and run-time optimization in terms of avoiding instability.  
The results also show that the faster of our two developed algorithms achieves a speedup ranging from $2.26 \times 10^3$ to $4.37 \times 10^6$ times compared to the ILP approach, while the maximum delay is, on average, only 1.029 times the optimal value.
The results indicate that the speedup effect becomes more significant as the number of users and servers increases.
\end{abstract}
% \vspace{-0.3cm}
\begin{IEEEkeywords}
  Server allocation, data consistency, preventive start-time optimization, server failure, approximation algorithm.
\end{IEEEkeywords}

% \vspace{-0.5cm}
\section{Introduction}
\label{sec:introduction}

\red{
With the development of fifth-generation (5G) mobile networks~\cite{DOCOMO_5G}, the need for low latency in real-time applications such as ticket reservation systems and online gaming has increased.
These applications also require event order to be preserved.
Traditionally, centralized processing (CP) is used, where a central server manages event ordering.
This method requires the central server to wait for the maximum delay from the most distant user to process events in sequence, resulting in significant delays.
}

\red{
Kawabata~{\it et~al.}~\cite{2Kawabata2017} introduced a distributed server processing (DSP) approach that leverages edge computing~\cite{edge_26,edge_27,edge_28,edge_29}. 
In this approach, each user connects to one distributed server. 
Subsequently, each server forwards user-generated events to other servers, allowing them to store and manage these events, which is an additional step compared to centralized processing (CP). 
Finally, each server sends the processing results back to the users. 
Let $D_\mathrm{U}^{\max}$ and $D_\mathrm{S}^{\max}$ represent the maximum delays between servers and users and between servers, respectively. 
These three steps take at most $D_\mathrm{U}^{\max}$, $D_\mathrm{S}^{\max}$, and $D_\mathrm{U}^{\max}$ time, respectively. 
Thus, DSP incurs a total maximum delay of $2D_\mathrm{U}^{\max} + D_\mathrm{S}^{\max}$. 
The authors~\cite{2Kawabata2017} addressed a server allocation method to minimize this total delay. 
Similarly, the delay for CP can be expressed as $2D_\mathrm{U}^{\max}$. 
Since each user connects to a nearby server in DSP, $D_\mathrm{U}^{\max}$ is smaller than in CP, reducing the total delay. 
However, DSP does not consider transmission errors when servers forward events. 
As a result, events received by different servers may vary, leading to inconsistent processing results being returned to users.
}

\red{
Servers can fail for various reasons, including hardware malfunctions, software errors, and excessive load~\cite{5_9_8_Shi2016}. 
Due to the geographical distribution and the complexity of managing and maintaining edge servers, they are more prone to failures than centralized cloud servers.
When a server fails, the users connected to it must be reassigned to another server to restore service, which can affect the maximum total delay.
The work in~\cite{5_9_Masuda2020} developed a distributed server allocation model for DSP against single-server failures. % Masuda論文から追加
The server allocation problem for CMND handling server failures has not been thoroughly explored.
Since single-server failures are more common than multiple simultaneous failures, this paper focuses on the scenario of single-server failures.
}

\red{
One method to handle server allocation in the event of a single server failure is to first determine the optimal allocation without considering any failures and then decide on a reallocation after each failure occurs.
More specifically, start-time optimization (SO) reassigns users connected to the failed server to other non-failed servers to minimize the total delay for that failure scenario. On the other hand, 
run-time optimization (RO) reassigns all users to non-failed servers to minimize the total delay for that failure scenario.
SO provides the optimal allocation when no failures occur.
However, this start-time optimal allocation may not yield optimal solutions for other failure scenarios.
Conversely, RO always finds the optimal allocation for each failure scenario, but it may reassign users to new servers even if their current server has not failed.
This can lead to instability due to unnecessary disconnections.
}

\red{
Another method to handle server allocation in the event of a single server failure is preventive start-time optimization (PSO). The original concept of PSO was introduced in the network optimization studies~\cite{5_9_13_Kamrul2010,OkiDRCN2014} to minimize network congestion against failures while suppressing service interruption.
In PSO, users are preventively assigned to servers to minimize the largest total delay among all failure scenarios. 
To avoid instability, as in SO, PSO does not allow users connected to non-failed servers to be reassigned to other non-failed servers when a server fails.
% サービスの中断をなくし，全ての故障シナリオを考えた時の全体の遅延時間を最小化するためにはPSOが有効である．
PSO effectively minimizes the largest total delay among all failure scenarios while avoiding service interruptions.
}

\red{
Two questions arise: 
% 1. モデルを開発することができるのか
% 2. そういう問題に対する効率的なアルゴリズムがあるのか
1) Can we develop a model for the server allocation problem for CMND with PSO against single-server failures (CMND-PSO)?
2) Is there any efficient algorithm for the problem?
}

\red{
This paper proposes a server allocation model for CMND with PSO against single-server failures.
The proposed model preventively allocates users to servers and determines the secondary servers for each server to minimize the largest total delay among all failure scenarios.
To suppress instability, the proposed model does not allow users connected to non-failed servers to be reallocated to other non-failed servers when a server fails.
We formulate the proposed model as an ILP problem.
We prove that the decision version of CMND-PSO is NP-complete.
Since it is difficult to solve the problem in a practical time when the problem size is large, we introduce approximation algorithms with theoretical performance analysis.
We denote $a$ as the maximum delay between a user and a server among all failure scenarios in the optimal solution and $b$ as the maximum delay between servers among all failure scenarios in the optimal solution.
We also denote $c$ as the maximum delay between a server and its secondary servers among all failure scenarios in the optimal solution.
We theoretically prove that the proposed approximation algorithms can obtain a solution within a constant factor of $2a+b+c$ and analyze the computation time.
Numerical results show that the proposed server allocation model for CMND with PSO against a single failure outperforms SO in terms of the largest total delay and RO in terms of avoiding instability.
The results also show that our approximation algorithms can obtain a solution in a practical time while the approximate value is close to the optimal value.
}

% \vspace{-0.3cm}
\section{Related work and limitations of existing models}
\label{sec:related_work}

\begin{figure}[tb]
  \begin{center}
      %\begin{tabular}{c}
      \includegraphics[width=0.99\columnwidth]{./fig/tnsm/DSA_SOROPSO.pdf}
  \end{center}
    % \vspace{-0.4cm}
  \caption{\red{Example of distributed server allocation with SO, RO, and PSO.}}
  \label{fig:DSA_SOROPSO}
\end{figure}

\red{
The model in~\cite{5_9_Masuda2020} addressed single-server failures in DSP with PSO.
Fig.~\ref{fig:DSA_SOROPSO} illustrates the distributed server allocation with SO, RO, and PSO.
$f$ represents the failed server.
When no server fails, $f = 0$, the total delay of SO is the smallest in feasible allocation.
However, since SO can reassign users only if the users are connected to the failed server, the total delay of SO is larger than that of PSO when $f = 1$ and $2$.
For example, in SO, since user~3 is assigned to server~2 when $f = 0$, user~3 has to be reassigned to server~2 when $f = 1$.
Since the total delay is minimized under this condition when $f = 1$, the total delay is larger than that of PSO.
Despite a value of $f$, the total delay of RO is always the smallest in feasible allocation.
However, this causes instability when $f = 1$ and $2$.
For example, in RO, user~3 is assigned to server~2 when $f = 0$, but user~3 is reassigned to server~3 when $f = 1$ while server~2 is not failed.
PSO can suppress the total delay while avoiding instability by considering all failure scenarios when determining the allocation.
However, the model in~\cite{5_9_Masuda2020} does not consider the possibility of data synchronization failure between servers.
Therefore, the model cannot be applied either.
}

\section{Proposed model: OSA-PSO}
\label{sec:proposed_mode_cmnd_pso}

\subsection{Problem definitions}

We present the formal definition of CMND-PSO. Let the network be represented by an undirected graph $G = (V, E)$.
Let $V$ denote the set of all nodes and $E$ the set of all edges in the network.
Let $V_{\rm{U}} \subseteq V$ be the set of users, and let $V_{\rm{S}} \subseteq V$ be the set of potential server locations, where $|V_{\rm{S}}| \geq 2$.
We can express $V_{\rm{S}}$ as $V_{\rm{S}} = \{1, \ldots, |V_{\rm{S}}|\}$.
Let $u \in V_{\rm{U}}$ represent a user and $s \in V_{\rm{S}}$ represent a server.
Note that $V_{\rm{U}} \cup V_{\rm{S}} = V$ and $V_{\rm{U}} \cap V_{\rm{S}} = \emptyset$.
Let $E_{\rm{U}} \subseteq E$ be the set of edges between users and servers, and $E_{\rm{S}} \subseteq E$ be the set of edges between servers.
An edge connecting a user $u \in V_{\rm{U}}$ to a server $s \in V_{\rm{S}}$ is represented as $(u,s) \in E_{\rm{U}}$.
An edge connecting two distinct servers $s, t \in V_{\rm{S}}$ is represented as $(s, t) \in E_{\rm{S}}$.
Note that $E_{\rm U} \cup E_{\rm S} =E$ and $E_{\rm{U}} \cap E_{\rm{S}} = \emptyset$.
\blue{Let $M_s$ be the maximum number of users that can be assigned to server $s \in V_{\rm{S}}$.}
This paper assumes that no more than one server can fail simultaneously.
Let $F = \{0, 1, \ldots, |V_{\rm{S}}|\}$ be the set of possible failure scenarios, where $f = 0$ corresponds to the scenario with no server failure, and each $f \in F \setminus \{0\}$ corresponds to the failure of server~$f$.

Let $d(u,s)$ represent the delay from user $u \in V_{\rm{U}}$ to server $s \in V_{\rm{S}}$, and let $d(s,t)$ denote the delay between servers $s, t \in V_{\rm{S}}$ with $s \neq t$.
We suppose $d(u,s) \geq 0$ and $d(u,s) = d(s,u)$ for all $u \in V_{\rm{U}}$ and $s \in V_{\rm{S}}$.
In addition, we require that $d(s,t) \geq 0$ for all $s, t \in V_{\rm{S}}$, that the delays are symmetric, i.e., $d(s,t) = d(t,s)$, and that the delay from a server to itself is zero, i.e., $d(s,s) = 0$.
% We also assume that the delays between servers satisfy the triangle inequality, i.e., $d(s_1,s_2) + d(s_2,s_3) \geq d(s_1,s_3)$ for every triple of elements $s_1, s_2, s_3 \in V_{\rm{S}}$. % 近似アルゴリズムは今回ないので不要
% この後，Oda_CMNDと同じように，査読後に追加した部分とユーザには三角不等式仮定しなくていいことを述べるべき？
Let $y_{sf}$ represent a binary variable that equals one if server $s \in V_{\rm{S}}$ is chosen in failure scenario $f \in F$, and zero otherwise.
Let $x_{ijf}$ represent a binary variable that equals one if the edge $(i,j) \in E$ is utilized in failure scenario $f \in F$, and zero otherwise.
For any user $u \in V_{\rm{U}}$ and server $s \in V_{\rm{S}}$, and for each failure scenario $f \in F$, the relation $x_{usf} \le y_{sf}$ holds. 
Similarly, for any pair of servers $s, t \in V_{\rm{S}}$ with $s \neq t$, and for each $f \in F$, we have $x_{stf} \le y_{sf}$ and $x_{stf} \le y_{tf}$. 
Let $D_{\mathrm{U}f}$ be the largest $d(u,s)$ among all $(u,s) \in E_{\rm{U}}$ used in scenario $f \in F$.
Let $D$ represent the largest total delay of $2D_{\mathrm{U}f}$ taken over all possible failure scenarios.
We define OSA-PSO as an optimization problem to minimize $D$.
% 
\begin{table}[tb]
    \centering
    \caption{Given parameters and decision parameters of OSA-PSO.}
    \label{tbl:notation_OSA-PSO}
    \begin{tabular}{p{1.3cm}|cp{5.4cm}}
        \hline
        \small
        Given & $V$ & Set of nodes. \\
        parameters & $V_{\rm{U}}$ & Set of users. \\
        & $V_{\rm{S}}$ & Set of potential server locations. \\
        & $E$ & Set of edges. \\
        & $E_{\rm{U}}$ & Set of edges between users and servers. \\
        & $E_{\rm{S}}$ & Set of edges between servers. \\
        & \blue{$M_s$} & \blue{Maximum number of users that can be assigned to server $s \in V_{\rm{S}}$.} \\
        & $d(u,s)$ & Delay between user~$u \in V_{\rm{U}}$ and $s \in V_{\rm{S}}$. \\
        & $d(s,t)$ & Delay between server~$s \in V_{\rm{S}}$ and $t \in V_{\rm{S}}$. \\ 
        & $F$ & Set of possible failure scenarios, where $f = 0$ corresponds to the scenario with no server failure, and each $f \in F \setminus \{0\}$ corresponds to the failure of server~$f$. \\
        & $H_{\rm APL}$ & Maximum status holding time of an aplication. \\
        & $H_s$ & Maximum status holding time of server $s$. \\ \hline
        Decision parameters & $D$ & The largest total delay of $2D_{\mathrm{U}f}$ taken over all possible failure scenarios. \\
        & $D_{\mathrm{U}f}$ & Largest $d(u,s)$ among all $(u,s) \in E_{\rm{U}}$ used in scenario $f \in F$. \\
        & $x_{ijf}$ & Binary. $x_{ijf} = 1$ if edge $(i,j) \in E_{\rm U} \cup E_{\rm S} (=E)$ is used under failure scenario~$f \in F$; $x_{ijf} = 0$ otherwise. \\
        & $y_{sf}$ & Binary. $y_{sf} = 1$ if server~$s \in V_{\rm{S}}$ is selected under failure scenario~$f \in F$; $y_{sf} = 0$ otherwise. \\ \hline
    \end{tabular}
\end{table}
Table~\ref{tbl:notation_OSA-PSO} summarises the given parameters and decision parameters used in the problem.

% \vspace{-0.5cm}
\subsection{Formulation of optimization problem}
The optimization problem of OSA-PSO to minimize $D$ is formulated as an ILP problem as follows:
\begin{subequations} \label{OSA-PSO}
  \begin{align}
  \text{Objective}&\text{ min}\quad D \label{OSA-PSO_a} \\
  \rm{s.t.} \quad
  &\sum_{s \in V_{\rm{S}} \setminus \{f\}} x_{usf} = 1, \quad \forall u \in V_{\rm{U}}, \; f \in F \label{OSA-PSO_b} \\
  &\blue{\sum_{u \in V_{\rm{U}}} x_{usf} = M_s, \quad \forall s \in V_{\rm{S}}, \; f \in F} \label{OSA-PSO_b'} \\  %近似アルゴリズムを考えないので，定式化ではサーバ容量制限も加えた．
  % &\sum_{u \in V_{\rm{U}}} x_{usf} = 0, \quad \mathrm{if} \; s = f, \; \forall f \in F \label{OSA-PSO_c} \\  % これだとOSAではうまくいかない．x_{usf}は0だが，y_{sf}が1となるということが起こってしまう．おそらく，x_{stf}がどこの制約も受けないから．
  &y_{sf} = 0, \quad \mathrm{if} \; s = f, \; \forall f \in F \label{OSA-PSO_c} \\  % これと(h)で，元の(c)式を満たす．さらに，これと(j)でx_{ftf}が0になり，上記のようなことは起こらなくなる（f=0に関しては）．他のfの時も含めて，おかしいのは新たに追加した(l)式で十分だと思うが，元の(c)式よりこちらの方が簡単なのでこのままにしておく．
  &x_{usf}d(u,s) \le D_{\mathrm{U}f}, \quad \forall (u,s) \in E_{\rm{U}}, \; f \in F \label{OSA-PSO_d} \\
  &2D_{\mathrm{U}f} \le D, \quad \forall f \in F \label{OSA-PSO_e} \\
  &x_{us0} \le x_{usf}, \notag \\
  &\qquad \forall f \in F \setminus \{0\}, \; u \in V_{\rm{U}}, \; s \in V_{\rm{S}} \setminus \{f\} \label{OSA-PSO_f} \\
  &x_{usf}d(u,s) + x_{stf}d(s,t) \le \min(H_{\rm APL},H_s), \notag \\
  &\qquad \forall s \in V_{\rm{S}}, (u,s) \in E_{\rm{U}}, (s,t) \in E_{\rm{S}}, f \in F \label{OSA-PSO_g} \\
  &y_{sf} \geq x_{usf}, \quad \forall (u,s) \in E_{\rm{U}}, \; f \in F \label{OSA-PSO_h} \\
  &y_{sf} + y_{tf} - 1 \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{OSA-PSO_i} \\
  &x_{stf} \le y_{sf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{OSA-PSO_j} \\
  &x_{stf} \le y_{tf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{OSA-PSO_k} \\
  &\sum_{u \in V_{\rm{U}}} x_{usf} \geq y_{sf} , \quad \forall s \in V_{\rm{S}}, \; f \in F \label{OSA-PSO_l} \\
  &x_{ijf} \in \{0,1\}, \quad \forall (i,j) \in E, \; f \in F \label{OSA-PSO_m} \\
  &y_{sf} \in \{0,1\}, \quad \forall s \in V_{\rm{S}}, \; f \in F. \label{OSA-PSO_n}
  \end{align}
\end{subequations}
% The optimization problem of CMND-PSO to minimize $D$ is formulated as an ILP problem as follows:
% \begin{subequations} \label{single-failure-without-capacity}
%   \begin{align}
%   \text{Objective}&\text{ min}\quad D \label{SFNC a} \\
%   \rm{s.t.} \quad
%   &\sum_{s \in V_{\rm{S}} \setminus \{f\}} x_{usf} = 1, \quad \forall u \in V_{\rm{U}}, \; f \in F \label{SFNC b} \\
%   &\sum_{u \in V_{\rm{U}}} x_{usf} = 0, \quad \mathrm{if} \; s = f, \; \forall f \in F \label{SFNC d} \\
%   &x_{usf}d(u,s) \le D_{\mathrm{U}f}, \quad \forall (u,s) \in E_{\rm{U}}, \; f \in F \label{SFNC e} \\
%   &x_{stf}d(s,t) \le D_{\mathrm{S}f}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC f} \\
%   &z_{stf}d(s,t) \le L_f, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC g} \\
%   &2D_{\mathrm{U}f}+D_{\mathrm{S}f}+L_f \le D, \quad \forall f \in F \label{SFNC h} \\
%   &x_{us0} \le x_{usf}, \notag \\
%   &\qquad \forall f \in F \setminus \{0\}, \; u \in V_{\rm{U}}, \; s \in V_{\rm{S}} \setminus \{f\} \label{SFNC i} \\
%   &y_{sf} \geq x_{usf}, \quad \forall (u,s) \in E_{\rm{U}}, \; f \in F \label{SFNC k} \\
%   &y_{sf} + y_{tf} - 1 \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC l} \\
%   &x_{stf} \le y_{sf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC m} \\
%   &x_{stf} \le y_{tf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC n} \\
%   &\sum_{s \in V_{\rm{S}} \setminus \{f\}} y_{sf} \geq N_{\rm{SS}} + 1, \quad \forall f \in F \label{SFNC o} \\
%   &z_{stf} \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{SFNC p} \\
%   &\sum_{t: \: (s,t) \in E_{\rm{S}}} z_{stf} = y_{sf} N_{\rm{SS}}, \notag \\
%   &\qquad \forall f \in F, \; s \in V_{\rm{S}} \setminus \{f\} \label{SFNC q} \\ % 7/19(金)前田くんのミーティングで，j:の後スペース開けるらしい
%   &\sum_{t: \: (s,t) \in E_{\rm{S}}} z_{stf} = 0, \quad \mathrm{if} \; s = f, \; \forall f \in F \label{SFNC r} \\
%   &\sum_{s: \: (s,t) \in E_{\rm{S}}} z_{stf} = 0, \quad \mathrm{if} \; t = f, \; \forall f \in F \label{SFNC s} \\
%   &x_{ijf} \in \{0,1\}, \quad \forall (i,j) \in E, \; f \in F \label{SFNC t} \\
%   &y_{sf} \in \{0,1\}, \quad \forall s \in V_{\rm{S}}, \; f \in F \label{SFNC u} \\
%   &z_{stf} \in \{0,1\}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F. \label{SFNC v}
%   \end{align}
% \end{subequations}

% \vspace{-0.3cm}
The formulation given in~\eqref{OSA-PSO_a}--\eqref{OSA-PSO_n} is described below.
Equation~\eqref{OSA-PSO_a} defines the objective function, aiming to minimize the largest total delay across all possible failure scenarios.
Equation~\eqref{OSA-PSO_b} ensures that, for every failure scenario, each user is connected to exactly one non-failed server.
\blue{Equation~\eqref{OSA-PSO_b'} ensures that, for every server in each failure scenario, the number of users assigned to that server does not exceed its capacity.}
Equation~\eqref{OSA-PSO_c} indicates that if a server fails in a failure scenario, it is used.
% indicates that a failed server cannot host any user under each failure scenario.
%
Equation~\eqref{OSA-PSO_d} computes $D_{\mathrm{U}f}$ as the maximum delay from any user to its assigned server in each failure scenario~$f$.
Equation~\eqref{OSA-PSO_e} calculates $D$ as the largest total delay of $2D_{\mathrm{U}f}$ across all possible failure scenarios.
% あるサーバがあるfailure scenarioにおいて故障していない場合，どのサーバも故障していないscenarioにおいてそのサーバに接続していたユーザはそのサーバに接続し続ける．
Equation~\eqref{OSA-PSO_f} ensures that, for any server that remains operational in a given failure scenario, users originally assigned to that server when no failures occur are not reassigned elsewhere.
Equation~\eqref{OSA-PSO_g} ensures that, for every server $s \in V_{\rm{S}}$, the maximum status holding time does not surpass the minimum of $H_{\rm APL}$ and $H_s$.
Equation~\eqref{OSA-PSO_h} guarantees that a server is considered active if it serves at least one user.
Equations~\eqref{OSA-PSO_i}--\eqref{OSA-PSO_k} indicates $x_{stf} = y_{sf} \cdot y_{tf}$.
Equation~\eqref{OSA-PSO_l} ensures that at least one user is assigned to each server in each failure scenario.

% 元の分散処理の定式化でy_ffが選ばれないようになってる？
% zについても同様のこと考慮できてる？

% \vspace{-0.3cm}
\section{NP-completeness}
\label{sec:NP-Completeness}

\blue{
We define the decision version of the OSA-based server allocation with PSO (D-OSA-PSO) as follows.
\begin{definition}
    Given a set of servers $V_{\rm{S}}$, a set of users $V_{\rm{U}}$, delay values between servers and between servers and users, the maximum number of users that can be assigned to each server $M_s\cyan{, s \in V_{\rm{S}}}$, a set of failure scenarios $F$, where at most one server in $V_{\rm{S}}$ may fail at any time, 
    and the maximum status holding \cyan{times, $H_{\rm APL}$ and $H_s$ of an application and server $s \in V_{\rm{S}}$, respectively, 
    is} there a feasible allocation of users to servers such that \cyan{the largest total delay $D$ defined in \eqref{OSA-PSO_a} does not exceed $h$, i.e., $D \leq h$, while satisfying the condition that, for every server $s \in V_{\rm{S}}$, the required status holding time does not exceed the minimum of $H_{\rm APL}$ and $H_s$?}
\end{definition}
\begin{thm}
D-OSA-PSO is NP-complete.
\end{thm}
}
\begin{proof}
  \blue{
  First, we show that D-OSA-PSO is in NP.
  % D-OSA-PSOのinstanceが与えられた時，その解がyes instanceかどうかを多項式時間で確認できる．
  Given a certificate of any instance of D-OSA-PSO, we can verify whether the solution is yes in polynomial time.  % 大木先生に25/01/30に送っていただいた本を参考にした．その本は間違ってないから，それに倣っていたら良いはず．
  For each failure scenario $f \in F$, verifying that every user is allocated to a server and determining the maximum user-to-server delay \cyan{$D_{\mathrm{U}f}$} can be accomplished in $O(|V_{\rm{U}}|)$ time.
  We can verify if the constraint of the maximum status holding time is satisfied in $O(|V_{\rm{U}}||V_{\rm{S}}|)$ time by checking the delay between each user and its assigned server, and the delay between each pair of servers.
  \cyan{We can also verify the total delay under failure scenario $f \in F$, $2D_{\mathrm{U}f}$, is less than or equal to $h$ in $O(1)$ time.}
  Since the number of failure scenarios is $|V_{\rm{S}}|+1$, the whole time complexity is $O(|V_{\rm{U}}||V_{\rm{S}}|^2)$.
  }

  \blue{
  Second, we prove that the 3-satisfiability problem (3-SAT), a well-known NP-complete problem~\cite{3_12_3SAT}, can be reduced to D-OSA-PSO in polynomial time. 
  3-SAT is defined as follows:
  {\it Given $n$ boolean variables and $k$ clauses, where each clause consists of three literals, does there exist an assignment of truth values to the variables such that every clause evaluates to true?}
  }

  \blue{
  Given any instance $I$ of 3-SAT, we construct an instance $J$ of D-OSA-PSO. \magenta{This construction ensures that $I$ is a yes-instance if and only if $J$ is a yes-instance.} %M1前期火1L13参考にした
  A schematic diagram illustrating this construction is provided in Fig.~\ref{fig:3SAT_RTC}.
  }
  \begin{figure}[!t]
    \begin{center}
      \includegraphics[width=0.8\columnwidth]{./fig/fig_3SAT_RTC.pdf}
    \end{center}
      % \vspace{-0.3cm}
    \caption{\blue{Graph $G$ corresponding to 3-SAT with three clauses.}}
    \label{fig:3SAT_RTC}
  \end{figure}

  \blue{
  \begin{itemize}
    \item Create a graph $G$ consisting of $k$ user nodes and $3k+1$ server nodes. The server nodes are consists of a server node $V_{\rm Z}$ and $3k$ server nodes grouped into $k$ sets, each containing three nodes $V_{ij}$ for $i = 1, 2, \cdots, k$ and $j = 1, 2, 3$, 
    \item All server nodes are linked with edges.
    \begin{itemize}
      \item The length of edges between $V_{ij}$ and $V_{i'j'}$ are set to one whenever $i \neq i'$, and $V_{ij}$ and $V_{i'j'}$ are not negations to each other, which means that the edge represents two nodes corresponding to elements that have a compatible true assignment.
      \item The length of edges between $V_{\rm Z}$ and $V_{ij}$ are set to one.
      \item Otherwise, the length of edges are set to two.
    \end{itemize}
    \item Each user node is linked with edges that have a length of zero.
    \item \magenta{We set $M_s = H_s = 1$ for all servers $s \in V_{\rm S}$, and $H_{\rm APL} = 1$. Thus, for every $s \in V_{\rm S}$, we have $\min(H_{\rm APL}, H_s) = 1$.}
    \item \magenta{We set the total delay threshold to $h = 2$.}
  \end{itemize}
  }
\magenta{The above construction can be performed in time $O(|E_{\rm S}| + |E_{\rm U}|)$.}

%  \blue{
%  We set the capacity of each server node $s\in V_{\rm S}$,  $M_s$, to one to complete the D-OSA-PSO instance.  We set $\min(H_{\rm APL},H_s)$ to one for all servers $s \in V_{\rm{S}}$.}

  \blue{
  The D-OSA-PSO instance is feasible if and only if there exists a satisfiable 3-SAT assignment, which is shown below.
  }

  \blue{
  Suppose that there exists a true 3-SAT assignment. 
  We consider three cases for at most one server failure in the following.
  First, if server node $V_{\rm Z}$ fails,
  we can choose $k$ nodes from $V_{ij}$, one corresponding to true assignment from each clause, which are all interconnected with edges of length one.
  We can assign the $k$ user nodes to the $k$ selected server nodes under this failure scenario.
  Since no edge with a length greater than one in $G$ is used and edges between user nodes and server nodes have a length of zero, \cyan{$2D_{\mathrm{U}f}$ is two and the required status holding time is one.}
  Second, if a server node $V_{ij}$ fails,
  we can reassign the user nodes assigned to the failed server node to server node $V_{\rm Z}$, which \cyan{ensures that $2D_{\mathrm{U}f}$ is two and the required status holding time is one.}
  Third, if no server fails, 
  we can assign each user node to the same server node as in the case where server node $V_{\rm Z}$ fails, which also \cyan{ensures that $2D_{\mathrm{U}f}$ is two and the required status holding time is one.}
  Hence, \cyan{the largest total delay $D = \max_{f \in F}{2D_{\mathrm{U}f}}$ is two, which satisfies $D \leq h$, and the required status holding time among all server failure scenarios is one.
  Therefore} the D-OSA-PSO instance is feasible.
  }

  \blue{
  Conversely, assume that an instance of D-OSA-PSO is yes.
  \cyan{Considering that} server node $V_{\rm Z}$ fails, there exists a set of $k$ fully interconnected server nodes with edges of length one between $V_{ij}$.
  From the definition of $G$, these server nodes correspond to variables with compatible true assignments.
  Thus, assigning the value true to the variables associated with these $k$ nodes ensures that every clause is satisfied.
  Therefore, the corresponding instance of 3-SAT is yes.
  }

  \blue{
  Since we have shown a polynomial-time reduction from 3-SAT to D-OSA-PSO, and D-OSA-PSO is in NP, it follows that D-OSA-PSO is NP-complete.
  }
\end{proof}

% \vspace{-0.3cm}
\section{Numerical results}
\label{sec:numerical_results}
\blue{
We evaluate the proposed model in terms of OSA and PSO.
% 
For our experiments, we consider two \cyan{networks}: the JPN Kanto region~\cite{JPN} and COST~239~\cite{COST}. 
The potential servers in each network are illustrated in Fig.~\ref{fig:ServerLocation}.
In each \cyan{network}, servers are interconnected using the shortest available path.
For instance, in the COST~239 network, node~6 reaches node~11 through node~9.
In each network, user locations are randomly generated within the latitude and longitude ranges indicated in Fig.~\ref{fig:ServerLocation}.
The delay is assumed to increase linearly with transmission distance, with a reference value of 0.5~ms per 100~km, following the approach in~\cite{KawabataICC2023}.
Distances for direct links between servers and links between servers and users are computed using spherical trigonometry based on geographic coordinates, as described in~\cite{12Imanaka2024}.
The distance $d_\mathrm{AB}$ between two locations A and B, given their longitudes $x_\mathrm{A}$, $x_\mathrm{B}$ and latitudes $y_\mathrm{A}$, $y_\mathrm{B}$, is computed as follows:
$d_\mathrm{AB} = R \arccos\left( \sin y_\mathrm{A} \sin y_\mathrm{B} + \cos y_\mathrm{A} \cos y_\mathrm{B} \cos(x_\mathrm{A} - x_\mathrm{B}) \right)$,
where $R$ denotes the equatorial radius\cyan{~\cite{Zohora2018}}.
All experiments are performed on a PC with an Intel(R) Core(TM) i7-7700 3.60GHz processor and 32 GB of memory.
We solve ILP problems using CPLEX 12.10.0.0\cite{CPLEX}.
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.47\columnwidth]{./fig/server_location_JPN_tight_fontsize22_OSA_r1.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/server_location_COST_tight_fontsize22_OSA_r1.pdf} \\
      (a) JPN Kanto & (b) COST~239
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{\blue{Potential server locations in JPN Kanto and COST~239.}}
  \label{fig:ServerLocation}
\end{figure}
}

\blue{
We conduct experiments \cyan{solving the ILP problem~\eqref{OSA-PSO_a}--\eqref{OSA-PSO_n} in the proposed model}, where $H_{\rm APL}$ and $H_s$ are fixed to given values, and the number of users is varied from 30 to 70 in steps of 10.
% server capacityの制限はなしで行う
We set $M_s$ to $V_{\rm U}$, which means that each server can accommodate all users; \magenta{we observe the basic characteristics of the proposed model, eliminating the impact of server capacity in this paper.}
For each configuration, we perform $n$ independent trials.
We set $n$ to 20 for all configurations
and use the average of the results.
}

\subsection{\cyan{Dependency on maximum status holding time}}
\label{subsec:Dependency_on_maximum_status_holding_time}

\blue{
We assess the delay and the computation time of OSA-PSO and the conventional \cyan{model}, which is CSA-based server allocation \cyan{model} with PSO (CSA-PSO) depends on the maximum status holding time, $H_{\rm APL}$ and $H_s$.
CSA-PSO is formulated as follows:
\begin{subequations} \label{CSA-PSO}
  \begin{align}
  \text{Objective}&\text{ min}\quad D \label{CSA-PSO_a} \\
  \rm{s.t.} \quad
  & \eqref{OSA-PSO_b}-\eqref{OSA-PSO_e}, \eqref{OSA-PSO_g}, \eqref{OSA-PSO_i}-\eqref{OSA-PSO_n} \label{CSA-PSO_b} \\
  &x_{stf}d(s,t) \le D_{\mathrm{S}f}, \quad \forall (s,t) \in E_{\rm{S}}, \; f \in F \label{CSA-PSO_c} \\
  &2D_{\mathrm{U}f} + D_{\mathrm{S}f} \leq D, \quad \forall f \in F. \label{CSA-PSO_d}
  \end{align}
\end{subequations}
}

\subsubsection{\cyan{Impact of $H_{\rm APL}$}}

\blue{
For the evaluation focusing on the application maximum status holding time, we set $H_s$ to $H_{\rm APL}$.
$H_{\rm APL}$ is set from 0.8~ms to 1.3~ms for JPN Kanto and from 7.0~ms to 12.0~ms for COST~239.
}

% ここからdelayの評価
\blue{
Figs.~\ref{fig:delay_OSA_CSA_hapl_JPN} and~\ref{fig:delay_OSA_CSA_hapl_COST} show how the delay varies when $H_{\rm APL}$ changes for both the proposed and conventional \cyan{models} in the JPN Kanto and COST~239 networks, respectively.
The delay of OSA decreases as $H_{\rm APL}$ increases for both networks.
When $H_{\rm APL} \geq 0.9$~ms for JPN Kanto and $H_{\rm APL} \geq 8.0$~ms for COST~239, the delay of OSA is lower than that of CSA.
% h_aplが大きい時にCSAの何%以下と言う記述はしないでおく．（%があまり低くないし，あまりダラダラ書いてられない）
}
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hapl_JPN_numU30_15.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hapl_JPN_numU70_15.pdf} \\
      (a) 30 users & (b) 70 users
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{\blue{Delay for JPN Kanto when $|V_{\rm U}| = 30, 70$ depending on $H_{\rm APL}$.}}
  \label{fig:delay_OSA_CSA_hapl_JPN}
\end{figure}
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hapl_COST_numU30_12.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hapl_COST_numU70_12.pdf} \\
      (a) 30 users & (b) 70 users
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{\blue{Delay for COST~239 when $|V_{\rm U}| = 30, 70$ depending on $H_{\rm APL}$.}}
  \label{fig:delay_OSA_CSA_hapl_COST}
\end{figure}
\blue{
When $H_{\rm APL}$ is reduced, assigning each user to their closest server may violate the maximum status holding time constraint specified in~\eqref{OSA-PSO_g}.
In such cases, to satisfy~\eqref{OSA-PSO_g}, some users must be assigned to more distant servers, which can help reduce delays between their assigned server and other servers.
This results in an increase in $D_{\mathrm{U}f}$, leading to a larger delay for OSA.
Figs.~\ref{fig:delay_OSA_CSA_hapl_JPN} and~\ref{fig:delay_OSA_CSA_hapl_COST} show that the delay values for 30 and 70 users are quite similar.
This is because the overall delay is determined by the user-server pair with the maximum distance; thus, the location of the most distant user becomes the dominant factor in the total delay.
As a result, when the farthest users in both the 30-user and 70-user cases are located at comparable distances from the servers, the maximum delay remains nearly unchanged.
From the above results, it can be concluded that regardless of the number of users or the network topology, the proposed OSA-PSO \cyan{model} is effective in reducing delay when $H_{\rm APL}$ is large.
}

% ここからcomputation timeの評価
\blue{
Tables~\ref{tab:ComputationTime_OSA_CSA_hapl_JPN} and~\ref{tab:ComputationTime_OSA_CSA_hapl_COST} show computation time for OSA and CSA at JPN Kanto and COST~239, respectively.
When $V_{\rm U} = 30, 40, 50$ at COST~239, the computation time of OSA is shorter than that of CSA.
When $V_{\rm U} = 60, 70$ at COST~239, the computation time of OSA at $H_{\rm APL} = 8.0$~ms is longer than that of CSA but shorter than that of CSA at other $H_{\rm APL}$ values.
In both networks, as the difference from a certain value of $H_{\rm APL}$ increases, the computation time tends to decrease.
% 近似アルゴリズムを今回は考えないので，以下のブロックを追加
For scenarios with up to 70 users, the computation time remains within a few minutes, depending on the network topology and the value of $H_{\rm APL}$. 
In practical situations, a short wait of several minutes before service initiation is permissible.
Since user locations are typically known beforehand, this computation can be performed prior to launching the application, making the required processing time acceptable.
}
\begin{table}[t]
  \caption{\blue{Comparison of computation time for each \cyan{model} at JPN Kanto.}}
  \label{tab:ComputationTime_OSA_CSA_hapl_JPN}
  \begin{center}
    \begin{tabular}{c|cccccc|c}
      \hline
      $|V_{\rm{U}}|$ & \multicolumn{6}{c|}{OSA [s]} & CSA [s] \\ \cline{2-7}
       & \multicolumn{6}{c|}{$H_{\rm{APL}}$ [ms]} & \\
       & 0.8 & 0.9 & 1.0 & 1.1 & 1.2 & 1.3 &  \\
      \hline
      % \hline
      30 & 1.2 &  4.7 &  5.9 &  4.4 &  1.5 &  1.2 &  4.3 \\
      40 & 1.4 &  7.2 &  9.1 &  8.0 &  4.9 &  2.0 &  7.4 \\
      50 & 1.7 & 10.0 & 13.6 & 11.5 &  9.2 &  5.3 & 10.4 \\
      60 & 1.8 & 15.8 & 18.5 & 16.8 & 11.5 &  8.1 & 14.4 \\
      70 & 1.6 & 24.7 & 28.7 & 24.5 & 19.6 & 12.5 & 22.4 \\
      \hline
    \end{tabular}
  \end{center}
\end{table}
\begin{table}[t]
  \caption{\blue{Conparison of computation time for each \cyan{model} at COST~239.}}
  \label{tab:ComputationTime_OSA_CSA_hapl_COST}
  \begin{center}
    \begin{tabular}{c|cccccc|c}
      \hline
      $|V_{\rm{U}}|$ & \multicolumn{6}{c|}{OSA [s]} & CSA [s] \\ \cline{2-7}
       & \multicolumn{6}{c|}{$H_{\rm{APL}}$ [ms]} & \\
       & 7.0 & 8.0 & 9.0 & 10.0 & 11.0 & 12.0 &  \\
      \hline
      % \hline
      30 & 19.1 &  24.1 &  8.7 &  6.3 &  3.8 &  3.8 &  27.6 \\
      40 & 33.2 &  44.8 & 17.9 & 11.0 &  5.9 &  3.8 &  47.3 \\
      50 & 55.1 &  72.7 & 31.7 & 13.4 & 10.4 &  5.9 &  86.4 \\
      60 & 67.8 & 150.7 & 61.6 & 22.6 & 18.9 & 10.9 &  84.9 \\
      70 & 82.2 & 201.0 & 91.4 & 30.5 & 15.5 & 29.1 & 112.7 \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

\subsubsection{\cyan{Impact with $H_s$}}
\blue{
For the evaluation focusing on the server maximum status holding time, we set $H_{\rm APL}$ to the maximum value of $H_s$.
In this evaluation, we investigate whether increasing the number of servers with higher $H_s$ values (i.e., those with greater memory resources) can result in a reduction in delay.
We set values of $H_s$ for JPN Kanto and COST~239, as shown in Table~\ref{tab:condition_hs_JPN_COST}.
}
\begin{table}[t]
  \caption{\blue{Values of $H_s$ defined in JPN Kanto and COST~239.}}
  \label{tab:condition_hs_JPN_COST}
  \begin{center}
    \begin{tabular}{c|c}
      \hline
      JPN-A & $0.8,\; \forall s \in V_{\rm S}$ \\
      JPN-B & $0.8\,(s=1,3,4,5,7,8),\;1.0\,(s=2,6)$ \\
      JPN-C & $0.8\,(s=1,3,5,7),\;1.0\,(s=2,4,6,8)$ \\
      \hline
      COST-A & $7.0,\; \forall s \in V_{\rm S}$ \\
      COST-B & $7.0\,(s=1,2,3,4,5,7,8,9,10,11),\;9.0\,(s=6,8)$ \\
      COST-C & $7.0\,(s=1,3,5,7,8,9,10,11),\;9.0\,(s=2,4,6,8)$ \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

\blue{
Figs.~\ref{fig:delay_OSA_CSA_hs_JPN} and~\ref{fig:delay_OSA_CSA_hs_COST} show how the delay varies when $H_s$ changes for both the proposed and conventional \cyan{models} in the JPN Kanto and COST~239 networks, respectively.
Figs.~\ref{fig:delay_OSA_CSA_hs_JPN} and~\ref{fig:delay_OSA_CSA_hs_COST} demonstrate that increasing the number of servers with greater memory resources leads to lower delays. 
These findings indicate that the proposed \cyan{model} leverages server memory resources efficiently to minimize delay.
}
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hs_JPN_numU30_15.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hs_JPN_numU70_15.pdf} \\
      (a) 30 users & (b) 70 users
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{\blue{Delay for JPN Kanto when $|V_{\rm U}| = 30, 70$ depending on $H_s$.}}
  \label{fig:delay_OSA_CSA_hs_JPN}
\end{figure}
\begin{figure}[t]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hs_COST_numU30_12.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/delay_OSA_CSA_hs_COST_numU70_12.pdf} \\
      (a) 30 users & (b) 70 users
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{\blue{Delay for COST~239 when $|V_{\rm U}| = 30, 70$ depending on $H_s$.}}
  \label{fig:delay_OSA_CSA_hs_COST}
\end{figure}

% \vspace{-0.3cm}
\subsection{\cyan{Comparison of proposed PSO model with SO and RO}}
\blue{
To demonstrate the effectiveness of PSO, we compare our proposed model against two \cyan{baselines}.
We evaluate the performance as the number of users varies, using both the JPN Kanto region and COST~239 networks.
We set $H_{\rm APL} = H_s = 1.1$~ms in JPN Kanto and $H_{\rm APL} = H_s = 10$~ms in COST~239.
}

\subsubsection{\blue{Baselines}}
\blue{
We consider two \cyan{baselines}: SO and RO.
Both methods first compute the assignment where no server failures to minimize the total delay.
When a server failure occurs, they then determine the reassignment for the affected scenario.
}
% Specifically, SO reallocates only those users whose server has failed to available servers to minimize the total delay in that scenario;
% RO reassigns all users to non-failed servers to minimize the total delay under this failure scenario.

\blue{
For SO and RO, we first solve the ILP problem formulated as follows:
\begin{subequations} \label{OSA-SO-f0}
  \begin{align}
  \text{Objective}&\text{ min}\quad 2D_{\mathrm{U}f} \label{OSA-SO-f0_a} \\
  \rm{s.t.} \quad
  & \eqref{OSA-PSO_b}, \eqref{OSA-PSO_d}, \eqref{OSA-PSO_g}-\eqref{OSA-PSO_n}, \; F = \{0\}. \label{OSA-SO-f0_b}
  \end{align}
\end{subequations}
This gives us the assignment under the scenario where no server fails, expressed as $x^0_{us}$ for $(u,s) \in E_{\rm{U}}$.
}

\blue{
For the next step for SO, we solve the optimization problem for each failure scenario $f \in F \setminus \{0\}$ formulated as follows:
\begin{subequations} \label{OSA-SO}
  \begin{align}
  \text{Objective}&\text{ min}\quad D^f \label{OSA-SO_a} \\
  \rm{s.t.} \quad
  % ------ 省略部分開始 ------
  & \eqref{OSA-PSO_b}-\eqref{OSA-PSO_d}, \eqref{OSA-PSO_g}-\eqref{OSA-PSO_n}, \; F = \{f\} \label{OSA-SO_b-d,g-n} \\
  % ------ 省略部分終了 ------
  &2D_{\mathrm{U}f} \le D^f \label{OSA-SO_h} \\
  &x^0_{us} \le x_{usf}, \quad \forall u \in V_{\rm{U}}, \; s \in V_{\rm{S}} \setminus \{f\}. \label{OSA-SO_i}
  \end{align}
\end{subequations}
% \begin{subequations} \label{SO}
%   \begin{align}
%   \text{Objective}&\text{ min}\quad D^f \label{SO a} \\
%   \rm{s.t.} \quad
%   % &\sum_{s \in V_{\rm{S}} \setminus \{f\}} x_{usf} = 1, \quad \forall u \in V_{\rm{U}}, \label{SO b} \\
%   % % &\red{\sum_{u \in V_{\rm{U}}} x_{usf} \le C_{s}, \quad \forall f \in F, \; s \in V_{\rm{S}} \setminus \{f\}} \label{SO c} \\
%   % &\sum_{u \in V_{\rm{U}}} x_{usf} = 0, \quad \mathrm{if} \; s = f, \label{SO d} \\
%   % &x_{usf}d(u,s) \le D_{\mathrm{U}f}, \quad \forall (u,s) \in E_{\rm{U}}, \label{SO e} \\
%   % &x_{stf}d(s,t) \le D_{\mathrm{S}f}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO f} \\
%   % &z_{stf}d(s,t) \le L_f, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO g} \\
%   % ------ 省略部分1開始 ------
%   & \eqref{SFNC b}-\eqref{SFNC g}, \; F = \{f\}, \label{SO b-g} \\
%   % ------ 省略部分1終了 ------
%   &2D_{\mathrm{U}f}+D_{\mathrm{S}f}+L_f \le D^f, \label{SO h} \\
%   &x^0_{us} \le x_{usf}, \quad \forall u \in V_{\rm{U}}, \; s \in V_{\rm{S}} \setminus \{f\} \label{SO i} \\
%   % % &\red{z_{st0} \le z_{stf},} \notag \\
%   % % &\red{\quad \forall f \in F \setminus \{0\}, \; s,t \in V_{\rm{S}} \setminus \{f\}, (s,t) \in E_{\rm{S}}} \label{SO j} \\
%   % &y_{sf} \geq x_{usf}, \quad \forall (u,s) \in E_{\rm{U}}, \label{SO k} \\
%   % &y_{sf} + y_{tf} - 1 \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO l} \\
%   % &x_{stf} \le y_{sf}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO m} \\
%   % &x_{stf} \le y_{tf}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO n} \\
%   % &\sum_{s \in V_{\rm{S}} \setminus \{f\}} y_{sf} \geq N_{\rm{SS}} + 1, \label{SO o} \\
%   % &z_{stf} \le x_{stf}, \quad \forall (s,t) \in E_{\rm{S}}, \label{SO p} \\
%   % &\sum_{t: \: (s,t) \in E_{\rm{S}}} z_{stf} = y_{sf} N_{\rm{SS}}, \quad \forall s \in V_{\rm{S}} \setminus \{f\} \label{SO q} \\ % 7/19(金)前田くんのミーティングで，j:の後スペース開けるらしい
%   % &\sum_{t: \: (s,t) \in E_{\rm{S}}} z_{stf} = 0, \quad \mathrm{if} \; s = f, \label{SO r} \\
%   % &\sum_{s: \: (s,t) \in E_{\rm{S}}} z_{stf} = 0, \quad \mathrm{if} \; t = f, \label{SO s} \\
%   % &x_{ijf} \in \{0,1\}, \quad \forall (i,j) \in E, \label{SO t} \\
%   % &y_{sf} \in \{0,1\}, \quad \forall s \in V_{\rm{S}}, \label{SO u} \\
%   % &z_{stf} \in \{0,1\}, \quad \forall (s,t) \in E_{\rm{S}}. \label{SO v}
%   % ------ 省略部分2開始 ------
%   & \eqref{SFNC k}-\eqref{SFNC v}, \; F = \{f\}. \label{SO k-v}
%   % ------ 省略部分2終了 ------
%   \end{align}
% \end{subequations}
Equation~\eqref{OSA-SO_b-d,g-n} enforces the same constraints as~\eqref{OSA-PSO_b}--\eqref{OSA-PSO_d} and~\eqref{OSA-PSO_g}--\eqref{OSA-PSO_n}, applied for the single failure scenario $F = \{f\}$.
While the SO formulation closely resembles that of PSO, there are notable distinctions between the two approaches.
In PSO, the assignments for all failure scenarios including the scenario with no server failure are jointly optimized by solving the ILP formulation~\eqref{OSA-PSO_a}--\eqref{OSA-PSO_n}, treating $x_{us0}$ in~\eqref{OSA-PSO_f} as a variable to be determined.
In contrast, SO first computes the assignment for the no-failure scenario by solving the ILP formulation~\eqref{OSA-SO-f0_a}--\eqref{OSA-SO-f0_b}, and subsequently, for each failure scenario, determines the reassignment by solving the ILP formulation~\eqref{OSA-SO_a}--\eqref{OSA-SO_i}, using the previously obtained $x^0_{us}$ in~\eqref{OSA-SO_i} as a given parameter.
For RO, the optimization problem for each failure scenario $f \in F \setminus \{0\}$ is formulated in the same way as SO, except that constraint~\eqref{OSA-SO_i} is omitted from~\eqref{OSA-SO_a}--\eqref{OSA-SO_i}.
}

\subsubsection{\blue{Experiment setup and metrics}}
\blue{
Following the approach in~\cite{5_9_13_Kamrul2010, 5_9_Masuda2020}, we assess the performance of the proposed model and \cyan{baselines} using the metrics described below.
To evaluate the benefit of PSO over SO, we define the reduction ratio of the largest total delay achieved by PSO compared to SO as
$\alpha = \frac{\max_{f \in F}D^f_{\rm SO} - D_{\rm PSO}}{\max_{f \in F}D^f_{\rm SO}}$.
We further evaluate the extent to which PSO increases the total delay in the no-failure scenario compared to SO. This penalty is calculated as
$\beta = \frac{D^0_{\rm PSO} - D^0_{\rm SO}}{D^0_{\rm SO}}$.
}

\blue{
To evaluate the performance of PSO relative to RO, we define the increase ratio of the largest total delay under PSO compared to RO as
$\gamma = \frac{D_{\rm PSO} - \max_{f \in F}D^f_{\rm RO}}{\max_{f \in F}D^f_{\rm RO}}$.
An unnecessary disconnection is defined as the reassignment of a user to a different server when their original server remains operational.
For each failure scenario $f \in F$, let $\nu_f$ denote the proportion of users experiencing such unnecessary disconnections.
% \muは平均として使いたいので，\nuに変更
The average proportion of users who experience unnecessary disconnections, calculated across all failure scenarios, is given by
$\nu = \frac{\sum_{f \in F \setminus \{0\}}\nu_f}{|F| - 1}$.
}

\subsubsection{\blue{Evaluation}}
\blue{
Figs.~\ref{fig:OSA_alpha_beta_JPN} and~\ref{fig:OSA_alpha_beta_COST} illustrate how $\alpha$ and $\beta$ vary as the number of users increases in the JPN Kanto region and COST~239 networks, respectively.
% average: alpha JPN:0.1956 COST:0.0070 total:0.1013, beta JPN:0.3829 COST:0.1048 total:0.2439
It can be seen that $\alpha$ tends to grow as the number of users increases in both networks, suggesting that PSO achieves larger reductions in total delay compared to SO as the user count rises.
On average, $\alpha$ is 0.10, with the highest observed value for a failure scenario at one trial being 0.41 in JPN Kanto.
It is observed that $\beta$ tends to decline slightly for $|V_{\rm U}| \geq 40$ in the JPN Kanto, with the overall average value of $\beta$ being 0.24.
}

\begin{figure}[tb]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/alpha_JPN_hapl_1.1_025.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/beta_JPN_hapl_1.0_05.pdf} \\
      (a) $\alpha$ & (b) $\beta$
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{\blue{Evalutaion of PSO with SO when the number of users varies in JPN Kanto region.}}
  \label{fig:OSA_alpha_beta_JPN}
\end{figure}

\begin{figure}[tb]
  \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width=0.46\columnwidth]{./fig/alpha_COST_hapl_1.1_001.pdf} &
      \includegraphics[width=0.46\columnwidth]{./fig/beta_COST_hapl_10.0_025.pdf} \\
      (a) $\alpha$ & (b) $\beta$
      \end{tabular}
  \end{center}
      % \vspace{-0.3cm}
  \caption{\blue{Evalutaion of PSO with SO when the number of users varies in COST~239.}}
  \label{fig:OSA_alpha_beta_COST}
\end{figure}

\blue{
Table~\ref{tab:OSA-PSO_gamma_nu} presents the results for $\gamma$ and $\nu$ as the number of users varies in both the JPN Kanto region and COST~239 networks.
% average value \gamma: JPN:4.267*10e-4, COST:0, total:2.134*10e-4
It is found that the average value of $\gamma$ is $2.1 \times 10^{-4}$, indicating that the largest total delay under PSO exceeds that of RO by only 0.021\% overall.
% average value \nu: JPN:0.448, COST:0.378, total:0.413
On average, $\nu$ is 0.41, indicating that 41\% of users experience unnecessary disconnections per failure scenario when using RO, while PSO completely eliminates such disconnections.
As the number of users grows in both networks, $\nu$ also rises, suggesting that PSO becomes increasingly effective at preventing instability with larger users.
}
\begin{table}[t]
  \caption{\blue{Evaluation of PSO with RO when the number of users varies.}}
  \label{tab:OSA-PSO_gamma_nu}
  \begin{center}
    \begin{tabular}{c|cc|cc}
      \hline
      & \multicolumn{2}{c|}{JPN Kanto} & \multicolumn{2}{c}{COST~239} \\ \cline{2-5}
      $|V_{\rm{U}}|$ & $\gamma$ & $\nu$ & $\gamma$ & $\nu$ \\
      \hline
      30 & $3.8 \times 10^{-4}$ & 0.42 & $0.0$ & 0.34 \\
      40 & $4.9 \times 10^{-4}$ & 0.43 & $0.0$ & 0.37 \\
      50 & $4.9 \times 10^{-4}$ & 0.44 & $0.0$ & 0.40 \\
      60 & $3.8 \times 10^{-4}$ & 0.47 & $0.0$ & 0.37 \\
      70 & $3.8 \times 10^{-4}$ & 0.48 & $0.0$ & 0.41 \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

\blue{
It is found that solving the PSO formulation~\eqref{OSA-PSO_a}--\eqref{OSA-PSO_n} for $|V_{\rm U}|=30$ in COST~239 requires 6.33~[s].
Under the same conditions, SO and RO need $2.96 \times 10^{-2}$~[s] to compute the initial assignment without failures.
For each failure scenario, the reassignment step takes $3.92 \times 10^{-3}$~[s] for SO and $2.39 \times 10^{-2}$~[s] for RO, resulting in total computation times of 0.073~[s] for SO and 0.293~[s] for RO.
These results indicate that PSO requires more computational time than SO and RO, as it solves a larger-scale optimization problem simultaneously.
Additionally, RO is slower than SO because it reassigns all users in each failure scenario, whereas SO only reallocates users whose servers have failed.
}

\blue{
% この段落は最終版では外して，extended versionで追加してもいいかも．
% \ref{subsec:Evaluation with maximum status holding time}と同様に$H_{\rm APL}$を変化させて，PSO，SO，ROを実行すると，SOはJPNで$H_{\rm APL} \leq 1.0$，COSTで$H_{\rm APL} \leq 9$のとき，実行可能解が存在しなかった．
We also conducte the proposed model and two \cyan{baselines} by varying the maximum status holding time $H_{\rm APL}$ as in~\ref{subsec:Evaluation with maximum status holding time}.
In this case, SO does not yield a feasible solution for $H_{\rm APL} \leq 1.0$ in JPN Kanto and $H_{\rm APL} \leq 9$ in COST~239.
% これは，maximum status holding timeの制約が厳しくなった際に，SOよりもPSOの方が柔軟に対応することができることを示している．
This indicates that PSO can adapt more flexibly than SO when the maximum status holding time constraint becomes stricter.
}

\blue{
Overall, the proposed PSO model achieves a lower largest total delay than SO by jointly optimizing across all failure scenarios, with an average improvement $\alpha$ of 0.10 and up to 0.41 in the worst case.
The largest total delay under PSO is nearly equivalent to that of RO.
Furthermore, PSO effectively eliminates instability due to unnecessary user reassignments, whereas RO results in an average of 41\% of users being unnecessarily reassigned per failure scenario.
}

% \vspace{-0.5cm}
\section{Conclusion}
\label{sec:conclusion}

\bibliography{IEEEabrv,Oda_optimistic_PSO}

\end{CJK}

\end{document}